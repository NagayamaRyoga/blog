{"pageProps":{"article":{"slug":"2019-05-08-writing-wasm-passes","title":"Binaryenを使用してWebAssemblyを操作するパスを作成する","publishedAt":"2019-05-08T00:00:00.000Z","tags":["WebAssembly","Binaryen"],"ogpImage":"https://nagayamaryoga.github.io/blog/images/2019-05-08-writing-wasm-passes.png","bodyContent":"LLVMはLLVM IRを操作・走査できるカスタムパスの作成をサポートしており、`opt`コマンドの`-load`オプションを利用することで作成したカスタムパスを簡単に適用できます。\n\n参考： [LLVM documentation - Writing an LLVM Pass](http://llvm.org/docs/WritingAnLLVMPass.html)\n\n同じく、[WebAssembly](https://webassembly.org/)のライブラリ・コンパイラ基盤である[Binaryen](https://github.com/WebAssembly/binaryen)でもカスタムパスの作成はサポートされています。\nしかし、LLVMにおける`opt`コマンドのような簡易的なドライバツールは付属されていないためドライバ部分もユーザが記述しなければなりません。\n\n本稿ではWebAssembly中の定数命令の数を数える単純なコマンドラインツールの作成を通じて、以下の習得を目指します。\n\n1. 任意のC/C++プロジェクトでBinaryenをライブラリとして利用する方法\n2. WebAssemblyに対するカスタムパスの記述方法、および、その適用方法\n\n## Binaryenとは\n\n[Binaryen](https://github.com/WebAssembly/binaryen)はC++で記述された、WebAssembly操作するためのライブラリおよびツールチェインを提供するコンパイラ基盤です。\nBinaryenが提供するツールには例えば以下のようなものがあります。\n\n- `wasm-opt`： WebAssemblyに、あらかじめ用意された最適化パスなどを適用するためのツール。\n- `wasm-as`： テキスト形式(`.wast`ファイル)のWebAssemblyをバイナリ形式(`.wasm`ファイル)へと変換するアセンブラ。\n- `wasm-dis`： バイナリ形式(`.wasm`ファイル)のWebAssemblyをテキスト形式(`.wast`ファイル)へと変換する逆アセンブラ。\n\n## カスタムパスの作成\n\nテキスト形式(`.wast`ファイル)あるいはバイナリ形式(`.wasm`ファイル)のWebAssemblyを読み込み、その中に含まれる定数命令(`i32.const`, `i64.const`, `f32.const`, `f64.const`)を数える単純なツールを作成します。\n\n以下のような単純なWebAssemblyモジュール`simple.wast`について、含まれる定数命令の数は1つのみなので次のような出力が得られれば成功です。\n\n#### simple.wast\n\n```lisp\n(module\n    (export \"add3\" (func $add3))\n    (func $add3 (param i32) (result i32)\n        (i32.add\n            (local.get 0)\n            (i32.const 3)))\n)\n```\n\n#### 実行例\n\n```shell\n$ count-const simple.wast\n1 const instruction(s)\n```\n\n作成したプロジェクトの一式はGitHubで公開しています。\n\n[binaryen-const-counter](https://github.com/NagayamaRyoga/binaryen-const-counter)\n\n## 1. ビルドルールを記述する\n\n### 1.1. CMakeLists.txtを記述する\n\nプロジェクトはCMakeを用いてビルドするため、[CMakeLists.txt](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/master/CMakeLists.txt)を記述する必要があります。\n\n#### CMakeLists.txt [(1行目-13行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L1-L13)\n\n```cmake\ncmake_minimum_required(VERSION 3.0.0)\n\nproject(binaryen-const-counter VERSION 1.0.0 LANGUAGES CXX)\n\n# ビルドオプションの指定\nset(CMAKE_CXX_FLAGS \"-std=c++17 -Wall -Wextra -Werror -pedantic\")\nset(CMAKE_CXX_FLAGS_DEBUG \"-g3 -O0 -pg\")\nset(CMAKE_CXX_FLAGS_RELEASE \"-O2 -DNDEBUG -march=native\")\nset(CMAKE_CXX_FLAGS_RELWITHDEBINFO \"-g3 -Og -pg\")\nset(CMAKE_CXX_FLAGS_MINSIZEREL \"-Os -DNDEBUG -march=native\")\n\nif (NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE Release)\nendif (NOT CMAKE_BUILD_TYPE)\n```\n\nビルドオプションなどは好みに応じて指定してください。\n\n### 1.2. Binaryenをライブラリとしてインポートする\n\nCMakeのプラグインであるExternalProjectを用いてBinaryenをインポートします。また、`pthread`をリンクする必要があるのでそのための準備も行います。\n\n#### CMakeLists.txt [(15行目-28行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L15-L28)\n\n```cmake\n# 環境ごとのThreadライブラリを見つける\nfind_package(Threads REQUIRED)\n\n# ExternalProjectを使用する\ninclude(ExternalProject)\n\n# Binaryenをビルド、インポートする\nExternalProject_Add(\n    binaryen\n    URL \"https://github.com/WebAssembly/binaryen/archive/version_83.tar.gz\"\n    PREFIX binaryen\n    INSTALL_COMMAND \"\"\n    TEST_COMMAND \"\"\n    CMAKE_ARGS\n        -DBUILD_STATIC_LIB=ON\n        -DCMAKE_BUILD_TYPE=Release\n)\n```\n\n`CMAKE_ARGS -DBUILD_STATIC_LIB=ON`を指定することで静的ライブラリファイルが生成されるようにしています。\n\nBinaryenは本稿執筆時点の最新バージョンである`version_83`をインポートしています。\nBinaryenは2019年5月現在も盛んに更新がなされているので使用する時点の最新バージョンを使用することをおすすめします。\n\n### 1.3. 生成されたBinaryenのライブラリファイルをCMakeプロジェクトとしてインポートする\n\n`ExternalProject_Add`でインポートしたプロジェクトはそのままでは他のターゲットにリンクできません。\n\nそのため、`IMPORTED`ターゲットを作成する作成する必要があります。\n\n#### CMakeLists.txt [(30行目-55行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L30-L55)\n\n```cmake\n# 展開されたBinaryenのソースパス、バイナリパスを取得する\nExternalProject_Get_Property(binaryen source_dir)\nExternalProject_Get_Property(binaryen binary_dir)\n\n# IMPORTEDライブラリターゲットを追加する\nadd_library(binaryen::binaryen STATIC IMPORTED)\n# ターゲットの依存関係を定義する\nadd_dependencies(binaryen::binaryen binaryen)\n\n# インポートする静的ライブラリのパス\nset(binaryen_LIBS\n    ${binary_dir}/lib/libwasm.a\n    ${binary_dir}/lib/libasmjs.a\n    ${binary_dir}/lib/libpasses.a\n    ${binary_dir}/lib/libcfg.a\n    ${binary_dir}/lib/libir.a\n    ${binary_dir}/lib/libemscripten-optimizer.a\n    ${binary_dir}/lib/libsupport.a\n    ${binary_dir}/lib/libwasm.a # 2度指定する(重要)\n    Threads::Threads\n)\n\n# 存在しないディレクトリをINTERFACE_INCLUDE_DIRECTORIESに指定すると\n# 警告が出るのでそれを回避するためにディレクトリを作成する\nfile(MAKE_DIRECTORY ${source_dir}/src)\n\n# IMPORTEDターゲットのincludeディレクトリと静的ライブラリファイルを指定する\nset_target_properties(binaryen::binaryen\n    PROPERTIES\n    IMPORTED_LOCATION ${binary_dir}/lib/libbinaryen.a\n    INTERFACE_INCLUDE_DIRECTORIES ${source_dir}/src\n    INTERFACE_LINK_LIBRARIES \"${binaryen_LIBS}\"\n)\n```\n\n重要なのは`libwasm.a`を2回指定していることです。\n\n`libwasm.a`と`libpasses.a`などは相互に参照しあっているため、最初と最後の両方に`libwasm.a`を指定しないとリンカエラーが発生してしまいます。\n\n### 1.4. カスタムパスのターゲットを追加する\n\n最後にカスタムパスをビルドするためにターゲットを追加します。\n\n#### CMakeLists.txt [(57行目-63行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L57-L63)\n\n\n```cmake\n# ターゲットを追加する\nadd_executable(count-const\n    main.cpp\n)\n\n# Binaryenをリンクする\ntarget_link_libraries(count-const\n    binaryen::binaryen\n)\n```\n\n以上でCMakeを使ったビルドルールの記述が完了しました。\n\n## 2. カスタムパスを作成する\n\n続いてBinaryenを利用してカスタムパスを作成していきます。\n\n### 2.1. WebAssemblyモジュールを読み込む\n\nコマンドライン引数で指定されたWebAssemblyファイルを読み込みます。\n\n#### main.cpp [(223行目-225行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L223-L225)\n\n```cpp\n// WebAssemblyモジュールを読み込む\nwasm::Module module;\nwasm::ModuleReader{}.read(argv[1], module);\n```\n\nWebAssemblyモジュールファイルを読み込むには、以下の関数のうちのいずれかを使用します。\n\n- `wasm::ModuleReader::readText()`\n\n    WebAssemblyテキストファイル(`.wast`形式)を読み込む。\n\n- `wasm::ModuleReader::readBinary()`\n\n    WebAssemblyバイナリファイル(`.wasm`形式)を読み込む。\n\n- `wasm::ModuleReader::read()`\n\n    テキストファイルかバイナリファイル化を自動で判断して読み込む。\n\nテキストファイル(`.wast`)とバイナリファイル(`.wasm`)の両方に対応したければ`read()`を使用すればよいです。\n\n読み込むときに注意すべき点は2つです。\n\n#### 1. 読み込むファイルが開けなければ`exit(1)`を呼び出す\n\n`readText()`、`readBinary()`、`read()`関数はファイルが開けない場合(存在しない場合など)には即座に`exit(EXIT_FAILURE)`を呼び出し終了します。\n\nよりよいエラーのハンドリングを行う場合には実装を参考に自ら読み込み処理を必要があります。\n\n#### 2. ファイル形式が間違っている場合に`wasm::ParseException`例外を投げる\n\n`readText()`、`readBinary()`、`read()`関数はファイルの形式が間違っている場合に`wasm::ParseException`例外を投げます。\n\nしかし、この`wasm::ParseException`は`std::exception`を**継承していない**ため注意が必要です。\n\n### 2.2. パスを実装する\n\nカスタムパスを実装するためには`wasm::Pass`抽象クラスを継承します。\n\n#### main.cpp [(193行目-214行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L193-L214)\n\n```cpp\n// カスタムパスクラス\nclass CountingPass : public wasm::Pass {\npublic:\n    // パスが実行されるときに呼び出されるメンバ関数\n    void run(wasm::PassRunner *pass_runner, wasm::Module *module) override {\n        // (省略)\n    }\n\n    // このパスが実行されたときにモジュールを改変するか\n    bool modifiesBinaryenIR() override {\n        // このカスタムパスはモジュールを改変しないのでfalseを返す\n        return false;\n    }\n};\n```\n\nこのパスを実行するには、`wasm::PassRunner`にこのクラスを登録します。\n\n#### main.cpp [(223行目-230行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L223-L230)\n\n```cpp\n// PassRunnerにカスタムパスを登録する\nwasm::PassRunner pass_runner{&module};\npass_runner.add<CountingPass>();\n\n// カスタムパスを実行する\n// CountingPass::run()が呼び出される\npass_runner.run();\n```\n\n### 2.3. 式木訪問器(Visitor)を実装する\n\nモジュールに含まれる定数命令の数を数えるには式木訪問器(Visitor)を作成するのがもっとも簡単です。\n\n#### main.cpp [(6行目-191行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L6-L191)\n\n```cpp\nstruct CountingVisitor\n    : public wasm::OverriddenVisitor<CountingVisitor, int> {\n    // (省略)\n}\n```\n\n訪問器の基底クラスには`wasm::Visitor<>`、`wasm::OverriddenVisitor<>`などいくつかのクラスがあります。\nそれぞれに特徴があるのですが、基本的には`wasm::OverriddenVisitor<>`を継承するのがよいでしょう。\n\n`wasm::OverriddenVisitor<>`の第1テンプレート引数に自身のクラス型を、第2テンプレート引数には個々の`visit`関数の返り値の型を指定します。\n\n`visit`関数は式木の各ノードを順番に走査するためのメンバ関数です。\n\n今回のVisitorの`visit`関数はそのノードと子ノードに含まれる定数命令の数を返します。\n\n例として、定数命令(`i32.const`命令など)と条件分岐命令(`if`命令)の`visit`関数を挙げます。\n\n#### 定数命令の`visit`関数 - main.cpp [(129行目-131行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L129-L131)\n\n```cpp\n// 定数命令のvisit関数\nint visitConst(wasm::Const *curr) {\n    return 1;\n}\n```\n\n`wasm::Const`は定数命令に対応するノードクラスです。\n\nこのノードは定数命令なので常に`1`を返します。\n\n#### 条件分岐命令の`visit`関数 - main.cpp [(17行目-27行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L17-L27)\n\n```cpp\n// 条件分岐命令のvisit関数\nint visitIf(wasm::If *curr) {\n    int count = 0; // 子ノードに含まれる定数命令の数\n\n    // 条件式に含まれる定数命令を数える\n    count += visit(curr->condition);\n\n    // then節ブロックに含まれる定数命令を数える\n    count += visit(curr->ifTrue);\n\n    // else節ブロックに含まれる定数命令を数える\n    if (curr->ifFalse)\n        count += visit(curr->ifFalse);\n\n    // 子ノードに含まれる定数命令の数を返す\n    return count;\n}\n```\n\n`wasm::If`は条件分岐命令(`if`命令)に対応するノードクラスです。\n\nこの命令は定数命令ではありませんが、3つのオペランドを持つためそれらのオペランド(子ノード)に含まれる定数命令を数える必要があります。\n\nただし、注意すべき点として一部の命令はそのオペランドの一部が**省略可能**であるため、子ノードを指すメンバ変数が`nullptr`になっていることがあります。\n\n`If`の`ifFalse`メンバも省略可能なオペランドを表す変数であるため、走査の前にそのオペランドが`nullptr`でないことを確認しなければなりません。\n\n### 2.4. 訪問器(Visitor)の呼び出し\n\n最後に作成したVisitorを呼び出す必要があります。\n\n#### main.cpp [(196行目-209行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L196-L209)\n\n```cpp\n// パスが実行されるときに呼び出されるメンバ関数\nvoid run(wasm::PassRunner *pass_runner, wasm::Module *module) override {\n    // Visitorオブジェクトを生成する\n    CountingVisitor visitor;\n\n    // モジュール内の関数に含まれる定数命令を数えていく\n    int count = 0;\n\n    for (const auto &function : module->functions) {\n        count += visitor.visitFunction(function.get());\n    }\n\n    // 出力する\n    std::cout << count << \" const instruction(s)\" << std::endl;\n}\n```\n\n以上でWebAssemblyを走査できる簡単なパスを作成できました。","bodyHtml":"<p>LLVMはLLVM IRを操作・走査できるカスタムパスの作成をサポートしており、<code>opt</code>コマンドの<code>-load</code>オプションを利用することで作成したカスタムパスを簡単に適用できます。</p>\n<p>参考： <a href=\"http://llvm.org/docs/WritingAnLLVMPass.html\">LLVM documentation - Writing an LLVM Pass</a></p>\n<p>同じく、<a href=\"https://webassembly.org/\">WebAssembly</a>のライブラリ・コンパイラ基盤である<a href=\"https://github.com/WebAssembly/binaryen\">Binaryen</a>でもカスタムパスの作成はサポートされています。\nしかし、LLVMにおける<code>opt</code>コマンドのような簡易的なドライバツールは付属されていないためドライバ部分もユーザが記述しなければなりません。</p>\n<p>本稿ではWebAssembly中の定数命令の数を数える単純なコマンドラインツールの作成を通じて、以下の習得を目指します。</p>\n<ol>\n<li>任意のC/C++プロジェクトでBinaryenをライブラリとして利用する方法</li>\n<li>WebAssemblyに対するカスタムパスの記述方法、および、その適用方法</li>\n</ol>\n<h2>Binaryenとは</h2>\n<p><a href=\"https://github.com/WebAssembly/binaryen\">Binaryen</a>はC++で記述された、WebAssembly操作するためのライブラリおよびツールチェインを提供するコンパイラ基盤です。\nBinaryenが提供するツールには例えば以下のようなものがあります。</p>\n<ul>\n<li><code>wasm-opt</code>： WebAssemblyに、あらかじめ用意された最適化パスなどを適用するためのツール。</li>\n<li><code>wasm-as</code>： テキスト形式(<code>.wast</code>ファイル)のWebAssemblyをバイナリ形式(<code>.wasm</code>ファイル)へと変換するアセンブラ。</li>\n<li><code>wasm-dis</code>： バイナリ形式(<code>.wasm</code>ファイル)のWebAssemblyをテキスト形式(<code>.wast</code>ファイル)へと変換する逆アセンブラ。</li>\n</ul>\n<h2>カスタムパスの作成</h2>\n<p>テキスト形式(<code>.wast</code>ファイル)あるいはバイナリ形式(<code>.wasm</code>ファイル)のWebAssemblyを読み込み、その中に含まれる定数命令(<code>i32.const</code>, <code>i64.const</code>, <code>f32.const</code>, <code>f64.const</code>)を数える単純なツールを作成します。</p>\n<p>以下のような単純なWebAssemblyモジュール<code>simple.wast</code>について、含まれる定数命令の数は1つのみなので次のような出力が得られれば成功です。</p>\n<h4>simple.wast</h4>\n<pre><code class=\"hljs\">(<span class=\"hljs-name\">module</span>\n    (<span class=\"hljs-name\">export</span> <span class=\"hljs-string\">&quot;add3&quot;</span> (<span class=\"hljs-name\">func</span> $add3))\n    (<span class=\"hljs-name\">func</span> $add3 (<span class=\"hljs-name\">param</span> i32) (<span class=\"hljs-name\">result</span> i32)\n        (<span class=\"hljs-name\">i32</span>.add\n            (<span class=\"hljs-name\">local</span>.get <span class=\"hljs-number\">0</span>)\n            (<span class=\"hljs-name\">i32</span>.const <span class=\"hljs-number\">3</span>)))\n)</code></pre><h4>実行例</h4>\n<pre><code class=\"hljs\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> count-const simple.wast</span>\n1 const instruction(s)</code></pre><p>作成したプロジェクトの一式はGitHubで公開しています。</p>\n<p><a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter\">binaryen-const-counter</a></p>\n<h2>1. ビルドルールを記述する</h2>\n<h3>1.1. CMakeLists.txtを記述する</h3>\n<p>プロジェクトはCMakeを用いてビルドするため、<a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/master/CMakeLists.txt\">CMakeLists.txt</a>を記述する必要があります。</p>\n<h4>CMakeLists.txt <a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L1-L13\">(1行目-13行目)</a></h4>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.0</span>.<span class=\"hljs-number\">0</span>)\n\n<span class=\"hljs-keyword\">project</span>(binaryen-const-counter VERSION <span class=\"hljs-number\">1.0</span>.<span class=\"hljs-number\">0</span> LANGUAGES CXX)\n\n<span class=\"hljs-comment\"># ビルドオプションの指定</span>\n<span class=\"hljs-keyword\">set</span>(CMAKE_CXX_FLAGS <span class=\"hljs-string\">&quot;-std=c++17 -Wall -Wextra -Werror -pedantic&quot;</span>)\n<span class=\"hljs-keyword\">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class=\"hljs-string\">&quot;-g3 -O0 -pg&quot;</span>)\n<span class=\"hljs-keyword\">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class=\"hljs-string\">&quot;-O2 -DNDEBUG -march=native&quot;</span>)\n<span class=\"hljs-keyword\">set</span>(CMAKE_CXX_FLAGS_RELWITHDEBINFO <span class=\"hljs-string\">&quot;-g3 -Og -pg&quot;</span>)\n<span class=\"hljs-keyword\">set</span>(CMAKE_CXX_FLAGS_MINSIZEREL <span class=\"hljs-string\">&quot;-Os -DNDEBUG -march=native&quot;</span>)\n\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">NOT</span> CMAKE_BUILD_TYPE)\n    <span class=\"hljs-keyword\">set</span>(CMAKE_BUILD_TYPE Release)\n<span class=\"hljs-keyword\">endif</span> (<span class=\"hljs-keyword\">NOT</span> CMAKE_BUILD_TYPE)</code></pre><p>ビルドオプションなどは好みに応じて指定してください。</p>\n<h3>1.2. Binaryenをライブラリとしてインポートする</h3>\n<p>CMakeのプラグインであるExternalProjectを用いてBinaryenをインポートします。また、<code>pthread</code>をリンクする必要があるのでそのための準備も行います。</p>\n<h4>CMakeLists.txt <a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L15-L28\">(15行目-28行目)</a></h4>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\"># 環境ごとのThreadライブラリを見つける</span>\n<span class=\"hljs-keyword\">find_package</span>(Threads REQUIRED)\n\n<span class=\"hljs-comment\"># ExternalProjectを使用する</span>\n<span class=\"hljs-keyword\">include</span>(ExternalProject)\n\n<span class=\"hljs-comment\"># Binaryenをビルド、インポートする</span>\nExternalProject_Add(\n    binaryen\n    URL <span class=\"hljs-string\">&quot;https://github.com/WebAssembly/binaryen/archive/version_83.tar.gz&quot;</span>\n    PREFIX binaryen\n    INSTALL_COMMAND <span class=\"hljs-string\">&quot;&quot;</span>\n    TEST_COMMAND <span class=\"hljs-string\">&quot;&quot;</span>\n    CMAKE_ARGS\n        -DBUILD_STATIC_LIB=<span class=\"hljs-keyword\">ON</span>\n        -DCMAKE_BUILD_TYPE=Release\n)</code></pre><p><code>CMAKE_ARGS -DBUILD_STATIC_LIB=ON</code>を指定することで静的ライブラリファイルが生成されるようにしています。</p>\n<p>Binaryenは本稿執筆時点の最新バージョンである<code>version_83</code>をインポートしています。\nBinaryenは2019年5月現在も盛んに更新がなされているので使用する時点の最新バージョンを使用することをおすすめします。</p>\n<h3>1.3. 生成されたBinaryenのライブラリファイルをCMakeプロジェクトとしてインポートする</h3>\n<p><code>ExternalProject_Add</code>でインポートしたプロジェクトはそのままでは他のターゲットにリンクできません。</p>\n<p>そのため、<code>IMPORTED</code>ターゲットを作成する作成する必要があります。</p>\n<h4>CMakeLists.txt <a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L30-L55\">(30行目-55行目)</a></h4>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\"># 展開されたBinaryenのソースパス、バイナリパスを取得する</span>\nExternalProject_Get_Property(binaryen source_dir)\nExternalProject_Get_Property(binaryen binary_dir)\n\n<span class=\"hljs-comment\"># IMPORTEDライブラリターゲットを追加する</span>\n<span class=\"hljs-keyword\">add_library</span>(binaryen::binaryen STATIC IMPORTED)\n<span class=\"hljs-comment\"># ターゲットの依存関係を定義する</span>\n<span class=\"hljs-keyword\">add_dependencies</span>(binaryen::binaryen binaryen)\n\n<span class=\"hljs-comment\"># インポートする静的ライブラリのパス</span>\n<span class=\"hljs-keyword\">set</span>(binaryen_LIBS\n    <span class=\"hljs-variable\">${binary_dir}</span>/lib/libwasm.a\n    <span class=\"hljs-variable\">${binary_dir}</span>/lib/libasmjs.a\n    <span class=\"hljs-variable\">${binary_dir}</span>/lib/libpasses.a\n    <span class=\"hljs-variable\">${binary_dir}</span>/lib/libcfg.a\n    <span class=\"hljs-variable\">${binary_dir}</span>/lib/libir.a\n    <span class=\"hljs-variable\">${binary_dir}</span>/lib/libemscripten-optimizer.a\n    <span class=\"hljs-variable\">${binary_dir}</span>/lib/libsupport.a\n    <span class=\"hljs-variable\">${binary_dir}</span>/lib/libwasm.a <span class=\"hljs-comment\"># 2度指定する(重要)</span>\n    Threads::Threads\n)\n\n<span class=\"hljs-comment\"># 存在しないディレクトリをINTERFACE_INCLUDE_DIRECTORIESに指定すると</span>\n<span class=\"hljs-comment\"># 警告が出るのでそれを回避するためにディレクトリを作成する</span>\n<span class=\"hljs-keyword\">file</span>(<span class=\"hljs-keyword\">MAKE_DIRECTORY</span> <span class=\"hljs-variable\">${source_dir}</span>/src)\n\n<span class=\"hljs-comment\"># IMPORTEDターゲットのincludeディレクトリと静的ライブラリファイルを指定する</span>\n<span class=\"hljs-keyword\">set_target_properties</span>(binaryen::binaryen\n    PROPERTIES\n    IMPORTED_LOCATION <span class=\"hljs-variable\">${binary_dir}</span>/lib/libbinaryen.a\n    INTERFACE_INCLUDE_DIRECTORIES <span class=\"hljs-variable\">${source_dir}</span>/src\n    INTERFACE_LINK_LIBRARIES <span class=\"hljs-string\">&quot;${binaryen_LIBS}&quot;</span>\n)</code></pre><p>重要なのは<code>libwasm.a</code>を2回指定していることです。</p>\n<p><code>libwasm.a</code>と<code>libpasses.a</code>などは相互に参照しあっているため、最初と最後の両方に<code>libwasm.a</code>を指定しないとリンカエラーが発生してしまいます。</p>\n<h3>1.4. カスタムパスのターゲットを追加する</h3>\n<p>最後にカスタムパスをビルドするためにターゲットを追加します。</p>\n<h4>CMakeLists.txt <a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L57-L63\">(57行目-63行目)</a></h4>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\"># ターゲットを追加する</span>\n<span class=\"hljs-keyword\">add_executable</span>(count-const\n    main.cpp\n)\n\n<span class=\"hljs-comment\"># Binaryenをリンクする</span>\n<span class=\"hljs-keyword\">target_link_libraries</span>(count-const\n    binaryen::binaryen\n)</code></pre><p>以上でCMakeを使ったビルドルールの記述が完了しました。</p>\n<h2>2. カスタムパスを作成する</h2>\n<p>続いてBinaryenを利用してカスタムパスを作成していきます。</p>\n<h3>2.1. WebAssemblyモジュールを読み込む</h3>\n<p>コマンドライン引数で指定されたWebAssemblyファイルを読み込みます。</p>\n<h4>main.cpp <a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L223-L225\">(223行目-225行目)</a></h4>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// WebAssemblyモジュールを読み込む</span>\nwasm::Module <span class=\"hljs-keyword\">module</span>;\nwasm::ModuleReader{}.<span class=\"hljs-built_in\">read</span>(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-keyword\">module</span>);</code></pre><p>WebAssemblyモジュールファイルを読み込むには、以下の関数のうちのいずれかを使用します。</p>\n<ul>\n<li>\n<p><code>wasm::ModuleReader::readText()</code></p>\n<p>WebAssemblyテキストファイル(<code>.wast</code>形式)を読み込む。</p>\n</li>\n<li>\n<p><code>wasm::ModuleReader::readBinary()</code></p>\n<p>WebAssemblyバイナリファイル(<code>.wasm</code>形式)を読み込む。</p>\n</li>\n<li>\n<p><code>wasm::ModuleReader::read()</code></p>\n<p>テキストファイルかバイナリファイル化を自動で判断して読み込む。</p>\n</li>\n</ul>\n<p>テキストファイル(<code>.wast</code>)とバイナリファイル(<code>.wasm</code>)の両方に対応したければ<code>read()</code>を使用すればよいです。</p>\n<p>読み込むときに注意すべき点は2つです。</p>\n<h4>1. 読み込むファイルが開けなければ<code>exit(1)</code>を呼び出す</h4>\n<p><code>readText()</code>、<code>readBinary()</code>、<code>read()</code>関数はファイルが開けない場合(存在しない場合など)には即座に<code>exit(EXIT_FAILURE)</code>を呼び出し終了します。</p>\n<p>よりよいエラーのハンドリングを行う場合には実装を参考に自ら読み込み処理を必要があります。</p>\n<h4>2. ファイル形式が間違っている場合に<code>wasm::ParseException</code>例外を投げる</h4>\n<p><code>readText()</code>、<code>readBinary()</code>、<code>read()</code>関数はファイルの形式が間違っている場合に<code>wasm::ParseException</code>例外を投げます。</p>\n<p>しかし、この<code>wasm::ParseException</code>は<code>std::exception</code>を<strong>継承していない</strong>ため注意が必要です。</p>\n<h3>2.2. パスを実装する</h3>\n<p>カスタムパスを実装するためには<code>wasm::Pass</code>抽象クラスを継承します。</p>\n<h4>main.cpp <a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L193-L214\">(193行目-214行目)</a></h4>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// カスタムパスクラス</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CountingPass</span> :</span> <span class=\"hljs-keyword\">public</span> wasm::Pass {\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">// パスが実行されるときに呼び出されるメンバ関数</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(wasm::PassRunner *pass_runner, wasm::Module *<span class=\"hljs-keyword\">module</span>)</span> <span class=\"hljs-keyword\">override</span> </span>{\n        <span class=\"hljs-comment\">// (省略)</span>\n    }\n\n    <span class=\"hljs-comment\">// このパスが実行されたときにモジュールを改変するか</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">modifiesBinaryenIR</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span> </span>{\n        <span class=\"hljs-comment\">// このカスタムパスはモジュールを改変しないのでfalseを返す</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n};</code></pre><p>このパスを実行するには、<code>wasm::PassRunner</code>にこのクラスを登録します。</p>\n<h4>main.cpp <a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L223-L230\">(223行目-230行目)</a></h4>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// PassRunnerにカスタムパスを登録する</span>\nwasm::PassRunner pass_runner{&amp;<span class=\"hljs-keyword\">module</span>};\npass_runner.add&lt;CountingPass&gt;();\n\n<span class=\"hljs-comment\">// カスタムパスを実行する</span>\n<span class=\"hljs-comment\">// CountingPass::run()が呼び出される</span>\npass_runner.<span class=\"hljs-built_in\">run</span>();</code></pre><h3>2.3. 式木訪問器(Visitor)を実装する</h3>\n<p>モジュールに含まれる定数命令の数を数えるには式木訪問器(Visitor)を作成するのがもっとも簡単です。</p>\n<h4>main.cpp <a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L6-L191\">(6行目-191行目)</a></h4>\n<pre><code class=\"hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">CountingVisitor</span>\n    :</span> <span class=\"hljs-keyword\">public</span> wasm::OverriddenVisitor&lt;CountingVisitor, <span class=\"hljs-keyword\">int</span>&gt; {\n    <span class=\"hljs-comment\">// (省略)</span>\n}</code></pre><p>訪問器の基底クラスには<code>wasm::Visitor&lt;&gt;</code>、<code>wasm::OverriddenVisitor&lt;&gt;</code>などいくつかのクラスがあります。\nそれぞれに特徴があるのですが、基本的には<code>wasm::OverriddenVisitor&lt;&gt;</code>を継承するのがよいでしょう。</p>\n<p><code>wasm::OverriddenVisitor&lt;&gt;</code>の第1テンプレート引数に自身のクラス型を、第2テンプレート引数には個々の<code>visit</code>関数の返り値の型を指定します。</p>\n<p><code>visit</code>関数は式木の各ノードを順番に走査するためのメンバ関数です。</p>\n<p>今回のVisitorの<code>visit</code>関数はそのノードと子ノードに含まれる定数命令の数を返します。</p>\n<p>例として、定数命令(<code>i32.const</code>命令など)と条件分岐命令(<code>if</code>命令)の<code>visit</code>関数を挙げます。</p>\n<h4>定数命令の<code>visit</code>関数 - main.cpp <a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L129-L131\">(129行目-131行目)</a></h4>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// 定数命令のvisit関数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">visitConst</span><span class=\"hljs-params\">(wasm::Const *curr)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n}</code></pre><p><code>wasm::Const</code>は定数命令に対応するノードクラスです。</p>\n<p>このノードは定数命令なので常に<code>1</code>を返します。</p>\n<h4>条件分岐命令の<code>visit</code>関数 - main.cpp <a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L17-L27\">(17行目-27行目)</a></h4>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// 条件分岐命令のvisit関数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">visitIf</span><span class=\"hljs-params\">(wasm::If *curr)</span> </span>{\n    <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 子ノードに含まれる定数命令の数</span>\n\n    <span class=\"hljs-comment\">// 条件式に含まれる定数命令を数える</span>\n    count += <span class=\"hljs-built_in\">visit</span>(curr-&gt;condition);\n\n    <span class=\"hljs-comment\">// then節ブロックに含まれる定数命令を数える</span>\n    count += <span class=\"hljs-built_in\">visit</span>(curr-&gt;ifTrue);\n\n    <span class=\"hljs-comment\">// else節ブロックに含まれる定数命令を数える</span>\n    <span class=\"hljs-keyword\">if</span> (curr-&gt;ifFalse)\n        count += <span class=\"hljs-built_in\">visit</span>(curr-&gt;ifFalse);\n\n    <span class=\"hljs-comment\">// 子ノードに含まれる定数命令の数を返す</span>\n    <span class=\"hljs-keyword\">return</span> count;\n}</code></pre><p><code>wasm::If</code>は条件分岐命令(<code>if</code>命令)に対応するノードクラスです。</p>\n<p>この命令は定数命令ではありませんが、3つのオペランドを持つためそれらのオペランド(子ノード)に含まれる定数命令を数える必要があります。</p>\n<p>ただし、注意すべき点として一部の命令はそのオペランドの一部が<strong>省略可能</strong>であるため、子ノードを指すメンバ変数が<code>nullptr</code>になっていることがあります。</p>\n<p><code>If</code>の<code>ifFalse</code>メンバも省略可能なオペランドを表す変数であるため、走査の前にそのオペランドが<code>nullptr</code>でないことを確認しなければなりません。</p>\n<h3>2.4. 訪問器(Visitor)の呼び出し</h3>\n<p>最後に作成したVisitorを呼び出す必要があります。</p>\n<h4>main.cpp <a href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L196-L209\">(196行目-209行目)</a></h4>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// パスが実行されるときに呼び出されるメンバ関数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(wasm::PassRunner *pass_runner, wasm::Module *<span class=\"hljs-keyword\">module</span>)</span> <span class=\"hljs-keyword\">override</span> </span>{\n    <span class=\"hljs-comment\">// Visitorオブジェクトを生成する</span>\n    CountingVisitor visitor;\n\n    <span class=\"hljs-comment\">// モジュール内の関数に含まれる定数命令を数えていく</span>\n    <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;function : <span class=\"hljs-keyword\">module</span>-&gt;functions) {\n        count += visitor.<span class=\"hljs-built_in\">visitFunction</span>(function.<span class=\"hljs-built_in\">get</span>());\n    }\n\n    <span class=\"hljs-comment\">// 出力する</span>\n    std::cout &lt;&lt; count &lt;&lt; <span class=\"hljs-string\">&quot; const instruction(s)&quot;</span> &lt;&lt; std::endl;\n}</code></pre><p>以上でWebAssemblyを走査できる簡単なパスを作成できました。</p>\n","preview":"LLVMはLLVM IRを操作・走査できるカスタムパスの作成をサポートしており、optコマンドの-loadオプションを利用することで作成したカスタムパスを簡単に適用できます。\n\n参考： LLVM documentation - Writing an LLVM Pass","sourceBase":"2019-05-08-writing-wasm-passes.md"}},"__N_SSG":true}