<!DOCTYPE html><html lang="ja"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Binaryenを使用してWebAssemblyを操作するパスを作成する | 有限猿定理</title><meta name="description" content="LLVMはLLVM IRを操作・走査できるカスタムパスの作成をサポートしており、optコマンドの-loadオプションを利用することで作成したカスタムパスを簡単に適用できます。

参考： LLVM documentation - Writing an LLVM Pass"/><meta property="og:type" content="article"/><meta property="og:title" content="Binaryenを使用してWebAssemblyを操作するパスを作成する"/><meta property="og:description" content="LLVMはLLVM IRを操作・走査できるカスタムパスの作成をサポートしており、optコマンドの-loadオプションを利用することで作成したカスタムパスを簡単に適用できます。

参考： LLVM documentation - Writing an LLVM Pass"/><meta property="og:site_name" content="有限猿定理"/><meta property="og:image" content="https://nagayamaryoga.github.io/blog/images/2019-05-08-writing-wasm-passes.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="next-head-count" content="10"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" data-href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100;300;500&amp;display=swap"/><link rel="preload" href="/blog/_next/static/css/5aa0d22ca45e4a86.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/5aa0d22ca45e4a86.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/blog/_next/static/chunks/webpack-a33a7aa0274c542e.js" defer=""></script><script src="/blog/_next/static/chunks/framework-6751a58a23a01658.js" defer=""></script><script src="/blog/_next/static/chunks/main-07c78142a707c78b.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-64c8249aaa7896a7.js" defer=""></script><script src="/blog/_next/static/chunks/cb1608f2-a6913ffae3345cb2.js" defer=""></script><script src="/blog/_next/static/chunks/a9a7754c-d37f8fc334ce4b8a.js" defer=""></script><script src="/blog/_next/static/chunks/188-fbb779a3e453e941.js" defer=""></script><script src="/blog/_next/static/chunks/650-bf7664d142475a1c.js" defer=""></script><script src="/blog/_next/static/chunks/pages/%5Barticle%5D-5c058f51ba69f719.js" defer=""></script><script src="/blog/_next/static/l5V8wPf0_DsbrjWIZ630X/_buildManifest.js" defer=""></script><script src="/blog/_next/static/l5V8wPf0_DsbrjWIZ630X/_ssgManifest.js" defer=""></script><script src="/blog/_next/static/l5V8wPf0_DsbrjWIZ630X/_middlewareManifest.js" defer=""></script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100;300;500&display=swap"/></head><body><div id="__next"><style data-emotion="css-global fia9wu">html,body{margin:0;height:100%;}body{background:#eaddf0;color:#2f3131;font-family:"游ゴシック Medium",YuGothic,YuGothicM,"Hiragino Kaku Gothic ProN","Hiragino Kaku Gothic Pro",メイリオ,Meiryo,sans-serif;}p{margin-block-start:1em;margin-block-end:1em;line-height:1.65;}*{box-sizing:border-box;}</style><style data-emotion="css 5zpk15">.css-5zpk15{margin:0 auto;padding:0 1rem;padding-bottom:1px;max-width:60rem;min-width:30rem;box-sizing:content-box;}</style><div class="css-5zpk15"><style data-emotion="css k8q833">.css-k8q833{display:grid;grid-template-rows:1fr auto;grid-template-columns:1fr;grid-template-areas:"brand links";margin:0.5rem 0;padding:0.5rem 2rem;background-color:#ffffff;-webkit-filter:drop-shadow(6px 6px 0 rgba(226, 52, 226, 0.3));filter:drop-shadow(6px 6px 0 rgba(226, 52, 226, 0.3));}</style><header class="css-k8q833"><style data-emotion="css 1fpjxui">.css-1fpjxui{grid-area:"header";margin:0;color:#e234e2;font-family:"Noto Sans JP",sans-serif;font-size:1.6rem;font-weight:100;}</style><h1 class="css-1fpjxui"><style data-emotion="css tdvcnh">.css-tdvcnh{color:inherit;-webkit-text-decoration:none;text-decoration:none;}</style><a class="css-tdvcnh" href="/blog/">有限猿定理</a></h1><style data-emotion="css 19116i7">.css-19116i7{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;margin:0;padding:0.2rem 0;list-style:none;color:#e234e2;font-family:"Noto Sans JP",sans-serif;font-size:1.2rem;font-weight:100;}</style><ul class="css-19116i7"><style data-emotion="css qithd7">.css-qithd7{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-margin-start:1.2rem;margin-inline-start:1.2rem;vertical-align:middle;}</style><li class="css-qithd7"><a href="/" class="css-tdvcnh"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="user" class="svg-inline--fa fa-user " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M224 256c70.7 0 128-57.31 128-128s-57.3-128-128-128C153.3 0 96 57.31 96 128S153.3 256 224 256zM274.7 304H173.3C77.61 304 0 381.6 0 477.3c0 19.14 15.52 34.67 34.66 34.67h378.7C432.5 512 448 496.5 448 477.3C448 381.6 370.4 304 274.7 304z"></path></svg> <!-- -->About<!-- --></a></li><li class="css-qithd7"><a href="https://github.com/NagayamaRyoga" class="css-tdvcnh"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg> <!-- -->GitHub<!-- --></a></li></ul></header><main><style data-emotion="css itkntc">.css-itkntc{margin-block-start:1rem;margin-block-end:1rem;padding-block-start:1.5rem;padding-block-end:1.5rem;-webkit-padding-start:2rem;padding-inline-start:2rem;-webkit-padding-end:2rem;padding-inline-end:2rem;background-color:#ffffff;-webkit-filter:drop-shadow(6px 6px 0 rgba(226, 52, 226, 0.3));filter:drop-shadow(6px 6px 0 rgba(226, 52, 226, 0.3));}</style><article class="css-itkntc"><style data-emotion="css 1d1gygi">.css-1d1gygi{color:#e234e2;font-family:"Noto Sans JP",sans-serif;font-weight:500;}</style><div class="css-1d1gygi"><a class="css-tdvcnh" href="/blog/2019-05-08-writing-wasm-passes">2019-5-8</a></div><style data-emotion="css 1cu0v5">.css-1cu0v5{margin-block-start:0.5rem;margin-block-end:0.5rem;border-bottom:solid 1px #e234e2;color:#e234e2;font-family:"Noto Sans JP",sans-serif;font-size:2rem;font-weight:100;}</style><h1 class="css-1cu0v5"><a class="css-tdvcnh" href="/blog/2019-05-08-writing-wasm-passes">Binaryenを使用してWebAssemblyを操作するパスを作成する</a></h1><style data-emotion="css lc6kdr">.css-lc6kdr{margin-block-start:0.5rem;margin-block-end:0.5rem;padding:0;color:#e234e2;font-family:"Noto Sans JP",sans-serif;font-size:0.8rem;list-style:none;}</style><ul class="css-lc6kdr"><style data-emotion="css 1c1ko54">.css-1c1ko54{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-margin-end:1em;margin-inline-end:1em;vertical-align:middle;}</style><li class="css-1c1ko54"><style data-emotion="css kke0mk">.css-kke0mk{color:#e234e2;-webkit-text-decoration:none;text-decoration:none;}</style><a class="css-kke0mk" href="/blog/tags/C++"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="tag" class="svg-inline--fa fa-tag " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M48 32H197.5C214.5 32 230.7 38.74 242.7 50.75L418.7 226.7C443.7 251.7 443.7 292.3 418.7 317.3L285.3 450.7C260.3 475.7 219.7 475.7 194.7 450.7L18.75 274.7C6.743 262.7 0 246.5 0 229.5V80C0 53.49 21.49 32 48 32L48 32zM112 176C129.7 176 144 161.7 144 144C144 126.3 129.7 112 112 112C94.33 112 80 126.3 80 144C80 161.7 94.33 176 112 176z"></path></svg> <!-- -->C++<!-- --></a></li><li class="css-1c1ko54"><a class="css-kke0mk" href="/blog/tags/WebAssembly"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="tag" class="svg-inline--fa fa-tag " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M48 32H197.5C214.5 32 230.7 38.74 242.7 50.75L418.7 226.7C443.7 251.7 443.7 292.3 418.7 317.3L285.3 450.7C260.3 475.7 219.7 475.7 194.7 450.7L18.75 274.7C6.743 262.7 0 246.5 0 229.5V80C0 53.49 21.49 32 48 32L48 32zM112 176C129.7 176 144 161.7 144 144C144 126.3 129.7 112 112 112C94.33 112 80 126.3 80 144C80 161.7 94.33 176 112 176z"></path></svg> <!-- -->WebAssembly<!-- --></a></li><li class="css-1c1ko54"><a class="css-kke0mk" href="/blog/tags/Binaryen"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="tag" class="svg-inline--fa fa-tag " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M48 32H197.5C214.5 32 230.7 38.74 242.7 50.75L418.7 226.7C443.7 251.7 443.7 292.3 418.7 317.3L285.3 450.7C260.3 475.7 219.7 475.7 194.7 450.7L18.75 274.7C6.743 262.7 0 246.5 0 229.5V80C0 53.49 21.49 32 48 32L48 32zM112 176C129.7 176 144 161.7 144 144C144 126.3 129.7 112 112 112C94.33 112 80 126.3 80 144C80 161.7 94.33 176 112 176z"></path></svg> <!-- -->Binaryen<!-- --></a></li></ul><div><style data-emotion="css 1bt6ade">.css-1bt6ade{margin-block-start:2.5rem;font-family:"游ゴシック Medium",YuGothic,YuGothicM,"Hiragino Kaku Gothic ProN","Hiragino Kaku Gothic Pro",メイリオ,Meiryo,sans-serif;font-weight:500;line-height:1.5;word-break:break-word;}.css-1bt6ade h1{margin-block-start:1em;margin-block-end:1em;font-size:2em;font-weight:100;color:#e234e2;border-block-end:solid 1px #e234e2;}.css-1bt6ade h2{margin-block-start:0.5em;margin-block-end:0.5em;font-size:1.5em;font-weight:100;color:#e234e2;border-block-end:solid 1px #e234e2;}.css-1bt6ade h3{margin-block-start:1.6em;margin-block-end:0.8em;font-size:1.2em;font-weight:100;color:#e234e2;}.css-1bt6ade table{border-collapse:collapse;}.css-1bt6ade table thead tr{border-bottom:double 3px #2f3131;}.css-1bt6ade table tbody tr{border-bottom:solid 1px #2f3131;}.css-1bt6ade table th,.css-1bt6ade table td{padding:0.5em 1em;}.css-1bt6ade strong{color:#e234e2;}.css-1bt6ade code{padding:0.2em 0.4em;font-size:0.9em;font-family:Consolas,"Courier New",Courier,Monaco,monospace;font-weight:500;background:#ececec;}.css-1bt6ade pre{padding:0.5em 0.8em;background:#f1f0f0;overflow:auto;}.css-1bt6ade pre code{background:none;}.css-1bt6ade hr{margin:1.5em 0;height:1px;background-color:#e234e2;border:none;}.css-1bt6ade blockquote{margin:1em 0;padding-left:1em;border-left:solid 4px #809ee9;}.css-1bt6ade a{color:#e234e2;}.css-1bt6ade .hljs-comment{color:#0f990f;}.css-1bt6ade .hljs-string{color:#ff7300;}.css-1bt6ade .hljs-name{color:#1c50df;}.css-1bt6ade .hljs-keyword{color:#1c50df;}.css-1bt6ade .hljs-number{color:#658116;}.css-1bt6ade .hljs-meta{color:#808080;}</style><div class="css-1bt6ade"><p>LLVMはLLVM IRを操作・走査できるカスタムパスの作成をサポートしており、<code>opt</code>コマンドの<code>-load</code>オプションを利用することで作成したカスタムパスを簡単に適用できます。</p>
<p>参考： <a href="http://llvm.org/docs/WritingAnLLVMPass.html">LLVM documentation - Writing an LLVM Pass</a></p>
<p>同じく、<a href="https://webassembly.org/">WebAssembly</a>のライブラリ・コンパイラ基盤である<a href="https://github.com/WebAssembly/binaryen">Binaryen</a>でもカスタムパスの作成はサポートされています。
しかし、LLVMにおける<code>opt</code>コマンドのような簡易的なドライバツールは付属されていないためドライバ部分もユーザが記述しなければなりません。</p>
<p>本稿ではWebAssembly中の定数命令の数を数える単純なコマンドラインツールの作成を通じて、以下の習得を目指します。</p>
<ol>
<li>任意のC/C++プロジェクトでBinaryenをライブラリとして利用する方法</li>
<li>WebAssemblyに対するカスタムパスの記述方法、および、その適用方法</li>
</ol>
<h2>Binaryenとは</h2>
<p><a href="https://github.com/WebAssembly/binaryen">Binaryen</a>はC++で記述された、WebAssembly操作するためのライブラリおよびツールチェインを提供するコンパイラ基盤です。
Binaryenが提供するツールには例えば以下のようなものがあります。</p>
<ul>
<li><code>wasm-opt</code>： WebAssemblyに、あらかじめ用意された最適化パスなどを適用するためのツール。</li>
<li><code>wasm-as</code>： テキスト形式(<code>.wast</code>ファイル)のWebAssemblyをバイナリ形式(<code>.wasm</code>ファイル)へと変換するアセンブラ。</li>
<li><code>wasm-dis</code>： バイナリ形式(<code>.wasm</code>ファイル)のWebAssemblyをテキスト形式(<code>.wast</code>ファイル)へと変換する逆アセンブラ。</li>
</ul>
<h2>カスタムパスの作成</h2>
<p>テキスト形式(<code>.wast</code>ファイル)あるいはバイナリ形式(<code>.wasm</code>ファイル)のWebAssemblyを読み込み、その中に含まれる定数命令(<code>i32.const</code>, <code>i64.const</code>, <code>f32.const</code>, <code>f64.const</code>)を数える単純なツールを作成します。</p>
<p>以下のような単純なWebAssemblyモジュール<code>simple.wast</code>について、含まれる定数命令の数は1つのみなので次のような出力が得られれば成功です。</p>
<h4>simple.wast</h4>
<pre><code class="hljs">(<span class="hljs-name">module</span>
    (<span class="hljs-name">export</span> <span class="hljs-string">&quot;add3&quot;</span> (<span class="hljs-name">func</span> $add3))
    (<span class="hljs-name">func</span> $add3 (<span class="hljs-name">param</span> i32) (<span class="hljs-name">result</span> i32)
        (<span class="hljs-name">i32</span>.add
            (<span class="hljs-name">local</span>.get <span class="hljs-number">0</span>)
            (<span class="hljs-name">i32</span>.const <span class="hljs-number">3</span>)))
)</code></pre><h4>実行例</h4>
<pre><code class="hljs"><span class="hljs-meta">$</span><span class="bash"> count-const simple.wast</span>
1 const instruction(s)</code></pre><p>作成したプロジェクトの一式はGitHubで公開しています。</p>
<p><a href="https://github.com/NagayamaRyoga/binaryen-const-counter">binaryen-const-counter</a></p>
<h2>1. ビルドルールを記述する</h2>
<h3>1.1. CMakeLists.txtを記述する</h3>
<p>プロジェクトはCMakeを用いてビルドするため、<a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/master/CMakeLists.txt">CMakeLists.txt</a>を記述する必要があります。</p>
<h4>CMakeLists.txt <a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L1-L13">(1行目-13行目)</a></h4>
<pre><code class="hljs"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)

<span class="hljs-keyword">project</span>(binaryen-const-counter VERSION <span class="hljs-number">1.0</span>.<span class="hljs-number">0</span> LANGUAGES CXX)

<span class="hljs-comment"># ビルドオプションの指定</span>
<span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;-std=c++17 -Wall -Wextra -Werror -pedantic&quot;</span>)
<span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="hljs-string">&quot;-g3 -O0 -pg&quot;</span>)
<span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="hljs-string">&quot;-O2 -DNDEBUG -march=native&quot;</span>)
<span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS_RELWITHDEBINFO <span class="hljs-string">&quot;-g3 -Og -pg&quot;</span>)
<span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS_MINSIZEREL <span class="hljs-string">&quot;-Os -DNDEBUG -march=native&quot;</span>)

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)
    <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)
<span class="hljs-keyword">endif</span> (<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)</code></pre><p>ビルドオプションなどは好みに応じて指定してください。</p>
<h3>1.2. Binaryenをライブラリとしてインポートする</h3>
<p>CMakeのプラグインであるExternalProjectを用いてBinaryenをインポートします。また、<code>pthread</code>をリンクする必要があるのでそのための準備も行います。</p>
<h4>CMakeLists.txt <a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L15-L28">(15行目-28行目)</a></h4>
<pre><code class="hljs"><span class="hljs-comment"># 環境ごとのThreadライブラリを見つける</span>
<span class="hljs-keyword">find_package</span>(Threads REQUIRED)

<span class="hljs-comment"># ExternalProjectを使用する</span>
<span class="hljs-keyword">include</span>(ExternalProject)

<span class="hljs-comment"># Binaryenをビルド、インポートする</span>
ExternalProject_Add(
    binaryen
    URL <span class="hljs-string">&quot;https://github.com/WebAssembly/binaryen/archive/version_83.tar.gz&quot;</span>
    PREFIX binaryen
    INSTALL_COMMAND <span class="hljs-string">&quot;&quot;</span>
    TEST_COMMAND <span class="hljs-string">&quot;&quot;</span>
    CMAKE_ARGS
        -DBUILD_STATIC_LIB=<span class="hljs-keyword">ON</span>
        -DCMAKE_BUILD_TYPE=Release
)</code></pre><p><code>CMAKE_ARGS -DBUILD_STATIC_LIB=ON</code>を指定することで静的ライブラリファイルが生成されるようにしています。</p>
<p>Binaryenは本稿執筆時点の最新バージョンである<code>version_83</code>をインポートしています。
Binaryenは2019年5月現在も盛んに更新がなされているので使用する時点の最新バージョンを使用することをおすすめします。</p>
<h3>1.3. 生成されたBinaryenのライブラリファイルをCMakeプロジェクトとしてインポートする</h3>
<p><code>ExternalProject_Add</code>でインポートしたプロジェクトはそのままでは他のターゲットにリンクできません。</p>
<p>そのため、<code>IMPORTED</code>ターゲットを作成する作成する必要があります。</p>
<h4>CMakeLists.txt <a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L30-L55">(30行目-55行目)</a></h4>
<pre><code class="hljs"><span class="hljs-comment"># 展開されたBinaryenのソースパス、バイナリパスを取得する</span>
ExternalProject_Get_Property(binaryen source_dir)
ExternalProject_Get_Property(binaryen binary_dir)

<span class="hljs-comment"># IMPORTEDライブラリターゲットを追加する</span>
<span class="hljs-keyword">add_library</span>(binaryen::binaryen STATIC IMPORTED)
<span class="hljs-comment"># ターゲットの依存関係を定義する</span>
<span class="hljs-keyword">add_dependencies</span>(binaryen::binaryen binaryen)

<span class="hljs-comment"># インポートする静的ライブラリのパス</span>
<span class="hljs-keyword">set</span>(binaryen_LIBS
    <span class="hljs-variable">${binary_dir}</span>/lib/libwasm.a
    <span class="hljs-variable">${binary_dir}</span>/lib/libasmjs.a
    <span class="hljs-variable">${binary_dir}</span>/lib/libpasses.a
    <span class="hljs-variable">${binary_dir}</span>/lib/libcfg.a
    <span class="hljs-variable">${binary_dir}</span>/lib/libir.a
    <span class="hljs-variable">${binary_dir}</span>/lib/libemscripten-optimizer.a
    <span class="hljs-variable">${binary_dir}</span>/lib/libsupport.a
    <span class="hljs-variable">${binary_dir}</span>/lib/libwasm.a <span class="hljs-comment"># 2度指定する(重要)</span>
    Threads::Threads
)

<span class="hljs-comment"># 存在しないディレクトリをINTERFACE_INCLUDE_DIRECTORIESに指定すると</span>
<span class="hljs-comment"># 警告が出るのでそれを回避するためにディレクトリを作成する</span>
<span class="hljs-keyword">file</span>(<span class="hljs-keyword">MAKE_DIRECTORY</span> <span class="hljs-variable">${source_dir}</span>/src)

<span class="hljs-comment"># IMPORTEDターゲットのincludeディレクトリと静的ライブラリファイルを指定する</span>
<span class="hljs-keyword">set_target_properties</span>(binaryen::binaryen
    PROPERTIES
    IMPORTED_LOCATION <span class="hljs-variable">${binary_dir}</span>/lib/libbinaryen.a
    INTERFACE_INCLUDE_DIRECTORIES <span class="hljs-variable">${source_dir}</span>/src
    INTERFACE_LINK_LIBRARIES <span class="hljs-string">&quot;${binaryen_LIBS}&quot;</span>
)</code></pre><p>重要なのは<code>libwasm.a</code>を2回指定していることです。</p>
<p><code>libwasm.a</code>と<code>libpasses.a</code>などは相互に参照しあっているため、最初と最後の両方に<code>libwasm.a</code>を指定しないとリンカエラーが発生してしまいます。</p>
<h3>1.4. カスタムパスのターゲットを追加する</h3>
<p>最後にカスタムパスをビルドするためにターゲットを追加します。</p>
<h4>CMakeLists.txt <a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L57-L63">(57行目-63行目)</a></h4>
<pre><code class="hljs"><span class="hljs-comment"># ターゲットを追加する</span>
<span class="hljs-keyword">add_executable</span>(count-const
    main.cpp
)

<span class="hljs-comment"># Binaryenをリンクする</span>
<span class="hljs-keyword">target_link_libraries</span>(count-const
    binaryen::binaryen
)</code></pre><p>以上でCMakeを使ったビルドルールの記述が完了しました。</p>
<h2>2. カスタムパスを作成する</h2>
<p>続いてBinaryenを利用してカスタムパスを作成していきます。</p>
<h3>2.1. WebAssemblyモジュールを読み込む</h3>
<p>コマンドライン引数で指定されたWebAssemblyファイルを読み込みます。</p>
<h4>main.cpp <a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L223-L225">(223行目-225行目)</a></h4>
<pre><code class="hljs"><span class="hljs-comment">// WebAssemblyモジュールを読み込む</span>
wasm::Module <span class="hljs-keyword">module</span>;
wasm::ModuleReader{}.<span class="hljs-built_in">read</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">module</span>);</code></pre><p>WebAssemblyモジュールファイルを読み込むには、以下の関数のうちのいずれかを使用します。</p>
<ul>
<li>
<p><code>wasm::ModuleReader::readText()</code></p>
<p>WebAssemblyテキストファイル(<code>.wast</code>形式)を読み込む。</p>
</li>
<li>
<p><code>wasm::ModuleReader::readBinary()</code></p>
<p>WebAssemblyバイナリファイル(<code>.wasm</code>形式)を読み込む。</p>
</li>
<li>
<p><code>wasm::ModuleReader::read()</code></p>
<p>テキストファイルかバイナリファイル化を自動で判断して読み込む。</p>
</li>
</ul>
<p>テキストファイル(<code>.wast</code>)とバイナリファイル(<code>.wasm</code>)の両方に対応したければ<code>read()</code>を使用すればよいです。</p>
<p>読み込むときに注意すべき点は2つです。</p>
<h4>1. 読み込むファイルが開けなければ<code>exit(1)</code>を呼び出す</h4>
<p><code>readText()</code>、<code>readBinary()</code>、<code>read()</code>関数はファイルが開けない場合(存在しない場合など)には即座に<code>exit(EXIT_FAILURE)</code>を呼び出し終了します。</p>
<p>よりよいエラーのハンドリングを行う場合には実装を参考に自ら読み込み処理を必要があります。</p>
<h4>2. ファイル形式が間違っている場合に<code>wasm::ParseException</code>例外を投げる</h4>
<p><code>readText()</code>、<code>readBinary()</code>、<code>read()</code>関数はファイルの形式が間違っている場合に<code>wasm::ParseException</code>例外を投げます。</p>
<p>しかし、この<code>wasm::ParseException</code>は<code>std::exception</code>を<strong>継承していない</strong>ため注意が必要です。</p>
<h3>2.2. パスを実装する</h3>
<p>カスタムパスを実装するためには<code>wasm::Pass</code>抽象クラスを継承します。</p>
<h4>main.cpp <a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L193-L214">(193行目-214行目)</a></h4>
<pre><code class="hljs"><span class="hljs-comment">// カスタムパスクラス</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingPass</span> :</span> <span class="hljs-keyword">public</span> wasm::Pass {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// パスが実行されるときに呼び出されるメンバ関数</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(wasm::PassRunner *pass_runner, wasm::Module *<span class="hljs-keyword">module</span>)</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-comment">// (省略)</span>
    }

    <span class="hljs-comment">// このパスが実行されたときにモジュールを改変するか</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">modifiesBinaryenIR</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-comment">// このカスタムパスはモジュールを改変しないのでfalseを返す</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};</code></pre><p>このパスを実行するには、<code>wasm::PassRunner</code>にこのクラスを登録します。</p>
<h4>main.cpp <a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L223-L230">(223行目-230行目)</a></h4>
<pre><code class="hljs"><span class="hljs-comment">// PassRunnerにカスタムパスを登録する</span>
wasm::PassRunner pass_runner{&amp;<span class="hljs-keyword">module</span>};
pass_runner.add&lt;CountingPass&gt;();

<span class="hljs-comment">// カスタムパスを実行する</span>
<span class="hljs-comment">// CountingPass::run()が呼び出される</span>
pass_runner.<span class="hljs-built_in">run</span>();</code></pre><h3>2.3. 式木訪問器(Visitor)を実装する</h3>
<p>モジュールに含まれる定数命令の数を数えるには式木訪問器(Visitor)を作成するのがもっとも簡単です。</p>
<h4>main.cpp <a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L6-L191">(6行目-191行目)</a></h4>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CountingVisitor</span>
    :</span> <span class="hljs-keyword">public</span> wasm::OverriddenVisitor&lt;CountingVisitor, <span class="hljs-keyword">int</span>&gt; {
    <span class="hljs-comment">// (省略)</span>
}</code></pre><p>訪問器の基底クラスには<code>wasm::Visitor&lt;&gt;</code>、<code>wasm::OverriddenVisitor&lt;&gt;</code>などいくつかのクラスがあります。
それぞれに特徴があるのですが、基本的には<code>wasm::OverriddenVisitor&lt;&gt;</code>を継承するのがよいでしょう。</p>
<p><code>wasm::OverriddenVisitor&lt;&gt;</code>の第1テンプレート引数に自身のクラス型を、第2テンプレート引数には個々の<code>visit</code>関数の返り値の型を指定します。</p>
<p><code>visit</code>関数は式木の各ノードを順番に走査するためのメンバ関数です。</p>
<p>今回のVisitorの<code>visit</code>関数はそのノードと子ノードに含まれる定数命令の数を返します。</p>
<p>例として、定数命令(<code>i32.const</code>命令など)と条件分岐命令(<code>if</code>命令)の<code>visit</code>関数を挙げます。</p>
<h4>定数命令の<code>visit</code>関数 - main.cpp <a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L129-L131">(129行目-131行目)</a></h4>
<pre><code class="hljs"><span class="hljs-comment">// 定数命令のvisit関数</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">visitConst</span><span class="hljs-params">(wasm::Const *curr)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre><p><code>wasm::Const</code>は定数命令に対応するノードクラスです。</p>
<p>このノードは定数命令なので常に<code>1</code>を返します。</p>
<h4>条件分岐命令の<code>visit</code>関数 - main.cpp <a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L17-L27">(17行目-27行目)</a></h4>
<pre><code class="hljs"><span class="hljs-comment">// 条件分岐命令のvisit関数</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">visitIf</span><span class="hljs-params">(wasm::If *curr)</span> </span>{
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子ノードに含まれる定数命令の数</span>

    <span class="hljs-comment">// 条件式に含まれる定数命令を数える</span>
    count += <span class="hljs-built_in">visit</span>(curr-&gt;condition);

    <span class="hljs-comment">// then節ブロックに含まれる定数命令を数える</span>
    count += <span class="hljs-built_in">visit</span>(curr-&gt;ifTrue);

    <span class="hljs-comment">// else節ブロックに含まれる定数命令を数える</span>
    <span class="hljs-keyword">if</span> (curr-&gt;ifFalse)
        count += <span class="hljs-built_in">visit</span>(curr-&gt;ifFalse);

    <span class="hljs-comment">// 子ノードに含まれる定数命令の数を返す</span>
    <span class="hljs-keyword">return</span> count;
}</code></pre><p><code>wasm::If</code>は条件分岐命令(<code>if</code>命令)に対応するノードクラスです。</p>
<p>この命令は定数命令ではありませんが、3つのオペランドを持つためそれらのオペランド(子ノード)に含まれる定数命令を数える必要があります。</p>
<p>ただし、注意すべき点として一部の命令はそのオペランドの一部が<strong>省略可能</strong>であるため、子ノードを指すメンバ変数が<code>nullptr</code>になっていることがあります。</p>
<p><code>If</code>の<code>ifFalse</code>メンバも省略可能なオペランドを表す変数であるため、走査の前にそのオペランドが<code>nullptr</code>でないことを確認しなければなりません。</p>
<h3>2.4. 訪問器(Visitor)の呼び出し</h3>
<p>最後に作成したVisitorを呼び出す必要があります。</p>
<h4>main.cpp <a href="https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L196-L209">(196行目-209行目)</a></h4>
<pre><code class="hljs"><span class="hljs-comment">// パスが実行されるときに呼び出されるメンバ関数</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(wasm::PassRunner *pass_runner, wasm::Module *<span class="hljs-keyword">module</span>)</span> <span class="hljs-keyword">override</span> </span>{
    <span class="hljs-comment">// Visitorオブジェクトを生成する</span>
    CountingVisitor visitor;

    <span class="hljs-comment">// モジュール内の関数に含まれる定数命令を数えていく</span>
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;function : <span class="hljs-keyword">module</span>-&gt;functions) {
        count += visitor.<span class="hljs-built_in">visitFunction</span>(function.<span class="hljs-built_in">get</span>());
    }

    <span class="hljs-comment">// 出力する</span>
    std::cout &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot; const instruction(s)&quot;</span> &lt;&lt; std::endl;
}</code></pre><p>以上でWebAssemblyを走査できる簡単なパスを作成できました。</p>
</div></div></article></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"slug":"2019-05-08-writing-wasm-passes","title":"Binaryenを使用してWebAssemblyを操作するパスを作成する","publishedAt":"2019-05-08T00:00:00.000Z","tags":["C++","WebAssembly","Binaryen"],"ogpImage":"https://nagayamaryoga.github.io/blog/images/2019-05-08-writing-wasm-passes.png","bodyContent":"LLVMはLLVM IRを操作・走査できるカスタムパスの作成をサポートしており、`opt`コマンドの`-load`オプションを利用することで作成したカスタムパスを簡単に適用できます。\n\n参考： [LLVM documentation - Writing an LLVM Pass](http://llvm.org/docs/WritingAnLLVMPass.html)\n\n同じく、[WebAssembly](https://webassembly.org/)のライブラリ・コンパイラ基盤である[Binaryen](https://github.com/WebAssembly/binaryen)でもカスタムパスの作成はサポートされています。\nしかし、LLVMにおける`opt`コマンドのような簡易的なドライバツールは付属されていないためドライバ部分もユーザが記述しなければなりません。\n\n本稿ではWebAssembly中の定数命令の数を数える単純なコマンドラインツールの作成を通じて、以下の習得を目指します。\n\n1. 任意のC/C++プロジェクトでBinaryenをライブラリとして利用する方法\n2. WebAssemblyに対するカスタムパスの記述方法、および、その適用方法\n\n## Binaryenとは\n\n[Binaryen](https://github.com/WebAssembly/binaryen)はC++で記述された、WebAssembly操作するためのライブラリおよびツールチェインを提供するコンパイラ基盤です。\nBinaryenが提供するツールには例えば以下のようなものがあります。\n\n- `wasm-opt`： WebAssemblyに、あらかじめ用意された最適化パスなどを適用するためのツール。\n- `wasm-as`： テキスト形式(`.wast`ファイル)のWebAssemblyをバイナリ形式(`.wasm`ファイル)へと変換するアセンブラ。\n- `wasm-dis`： バイナリ形式(`.wasm`ファイル)のWebAssemblyをテキスト形式(`.wast`ファイル)へと変換する逆アセンブラ。\n\n## カスタムパスの作成\n\nテキスト形式(`.wast`ファイル)あるいはバイナリ形式(`.wasm`ファイル)のWebAssemblyを読み込み、その中に含まれる定数命令(`i32.const`, `i64.const`, `f32.const`, `f64.const`)を数える単純なツールを作成します。\n\n以下のような単純なWebAssemblyモジュール`simple.wast`について、含まれる定数命令の数は1つのみなので次のような出力が得られれば成功です。\n\n#### simple.wast\n\n```lisp\n(module\n    (export \"add3\" (func $add3))\n    (func $add3 (param i32) (result i32)\n        (i32.add\n            (local.get 0)\n            (i32.const 3)))\n)\n```\n\n#### 実行例\n\n```shell\n$ count-const simple.wast\n1 const instruction(s)\n```\n\n作成したプロジェクトの一式はGitHubで公開しています。\n\n[binaryen-const-counter](https://github.com/NagayamaRyoga/binaryen-const-counter)\n\n## 1. ビルドルールを記述する\n\n### 1.1. CMakeLists.txtを記述する\n\nプロジェクトはCMakeを用いてビルドするため、[CMakeLists.txt](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/master/CMakeLists.txt)を記述する必要があります。\n\n#### CMakeLists.txt [(1行目-13行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L1-L13)\n\n```cmake\ncmake_minimum_required(VERSION 3.0.0)\n\nproject(binaryen-const-counter VERSION 1.0.0 LANGUAGES CXX)\n\n# ビルドオプションの指定\nset(CMAKE_CXX_FLAGS \"-std=c++17 -Wall -Wextra -Werror -pedantic\")\nset(CMAKE_CXX_FLAGS_DEBUG \"-g3 -O0 -pg\")\nset(CMAKE_CXX_FLAGS_RELEASE \"-O2 -DNDEBUG -march=native\")\nset(CMAKE_CXX_FLAGS_RELWITHDEBINFO \"-g3 -Og -pg\")\nset(CMAKE_CXX_FLAGS_MINSIZEREL \"-Os -DNDEBUG -march=native\")\n\nif (NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE Release)\nendif (NOT CMAKE_BUILD_TYPE)\n```\n\nビルドオプションなどは好みに応じて指定してください。\n\n### 1.2. Binaryenをライブラリとしてインポートする\n\nCMakeのプラグインであるExternalProjectを用いてBinaryenをインポートします。また、`pthread`をリンクする必要があるのでそのための準備も行います。\n\n#### CMakeLists.txt [(15行目-28行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L15-L28)\n\n```cmake\n# 環境ごとのThreadライブラリを見つける\nfind_package(Threads REQUIRED)\n\n# ExternalProjectを使用する\ninclude(ExternalProject)\n\n# Binaryenをビルド、インポートする\nExternalProject_Add(\n    binaryen\n    URL \"https://github.com/WebAssembly/binaryen/archive/version_83.tar.gz\"\n    PREFIX binaryen\n    INSTALL_COMMAND \"\"\n    TEST_COMMAND \"\"\n    CMAKE_ARGS\n        -DBUILD_STATIC_LIB=ON\n        -DCMAKE_BUILD_TYPE=Release\n)\n```\n\n`CMAKE_ARGS -DBUILD_STATIC_LIB=ON`を指定することで静的ライブラリファイルが生成されるようにしています。\n\nBinaryenは本稿執筆時点の最新バージョンである`version_83`をインポートしています。\nBinaryenは2019年5月現在も盛んに更新がなされているので使用する時点の最新バージョンを使用することをおすすめします。\n\n### 1.3. 生成されたBinaryenのライブラリファイルをCMakeプロジェクトとしてインポートする\n\n`ExternalProject_Add`でインポートしたプロジェクトはそのままでは他のターゲットにリンクできません。\n\nそのため、`IMPORTED`ターゲットを作成する作成する必要があります。\n\n#### CMakeLists.txt [(30行目-55行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L30-L55)\n\n```cmake\n# 展開されたBinaryenのソースパス、バイナリパスを取得する\nExternalProject_Get_Property(binaryen source_dir)\nExternalProject_Get_Property(binaryen binary_dir)\n\n# IMPORTEDライブラリターゲットを追加する\nadd_library(binaryen::binaryen STATIC IMPORTED)\n# ターゲットの依存関係を定義する\nadd_dependencies(binaryen::binaryen binaryen)\n\n# インポートする静的ライブラリのパス\nset(binaryen_LIBS\n    ${binary_dir}/lib/libwasm.a\n    ${binary_dir}/lib/libasmjs.a\n    ${binary_dir}/lib/libpasses.a\n    ${binary_dir}/lib/libcfg.a\n    ${binary_dir}/lib/libir.a\n    ${binary_dir}/lib/libemscripten-optimizer.a\n    ${binary_dir}/lib/libsupport.a\n    ${binary_dir}/lib/libwasm.a # 2度指定する(重要)\n    Threads::Threads\n)\n\n# 存在しないディレクトリをINTERFACE_INCLUDE_DIRECTORIESに指定すると\n# 警告が出るのでそれを回避するためにディレクトリを作成する\nfile(MAKE_DIRECTORY ${source_dir}/src)\n\n# IMPORTEDターゲットのincludeディレクトリと静的ライブラリファイルを指定する\nset_target_properties(binaryen::binaryen\n    PROPERTIES\n    IMPORTED_LOCATION ${binary_dir}/lib/libbinaryen.a\n    INTERFACE_INCLUDE_DIRECTORIES ${source_dir}/src\n    INTERFACE_LINK_LIBRARIES \"${binaryen_LIBS}\"\n)\n```\n\n重要なのは`libwasm.a`を2回指定していることです。\n\n`libwasm.a`と`libpasses.a`などは相互に参照しあっているため、最初と最後の両方に`libwasm.a`を指定しないとリンカエラーが発生してしまいます。\n\n### 1.4. カスタムパスのターゲットを追加する\n\n最後にカスタムパスをビルドするためにターゲットを追加します。\n\n#### CMakeLists.txt [(57行目-63行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L57-L63)\n\n\n```cmake\n# ターゲットを追加する\nadd_executable(count-const\n    main.cpp\n)\n\n# Binaryenをリンクする\ntarget_link_libraries(count-const\n    binaryen::binaryen\n)\n```\n\n以上でCMakeを使ったビルドルールの記述が完了しました。\n\n## 2. カスタムパスを作成する\n\n続いてBinaryenを利用してカスタムパスを作成していきます。\n\n### 2.1. WebAssemblyモジュールを読み込む\n\nコマンドライン引数で指定されたWebAssemblyファイルを読み込みます。\n\n#### main.cpp [(223行目-225行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L223-L225)\n\n```cpp\n// WebAssemblyモジュールを読み込む\nwasm::Module module;\nwasm::ModuleReader{}.read(argv[1], module);\n```\n\nWebAssemblyモジュールファイルを読み込むには、以下の関数のうちのいずれかを使用します。\n\n- `wasm::ModuleReader::readText()`\n\n    WebAssemblyテキストファイル(`.wast`形式)を読み込む。\n\n- `wasm::ModuleReader::readBinary()`\n\n    WebAssemblyバイナリファイル(`.wasm`形式)を読み込む。\n\n- `wasm::ModuleReader::read()`\n\n    テキストファイルかバイナリファイル化を自動で判断して読み込む。\n\nテキストファイル(`.wast`)とバイナリファイル(`.wasm`)の両方に対応したければ`read()`を使用すればよいです。\n\n読み込むときに注意すべき点は2つです。\n\n#### 1. 読み込むファイルが開けなければ`exit(1)`を呼び出す\n\n`readText()`、`readBinary()`、`read()`関数はファイルが開けない場合(存在しない場合など)には即座に`exit(EXIT_FAILURE)`を呼び出し終了します。\n\nよりよいエラーのハンドリングを行う場合には実装を参考に自ら読み込み処理を必要があります。\n\n#### 2. ファイル形式が間違っている場合に`wasm::ParseException`例外を投げる\n\n`readText()`、`readBinary()`、`read()`関数はファイルの形式が間違っている場合に`wasm::ParseException`例外を投げます。\n\nしかし、この`wasm::ParseException`は`std::exception`を**継承していない**ため注意が必要です。\n\n### 2.2. パスを実装する\n\nカスタムパスを実装するためには`wasm::Pass`抽象クラスを継承します。\n\n#### main.cpp [(193行目-214行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L193-L214)\n\n```cpp\n// カスタムパスクラス\nclass CountingPass : public wasm::Pass {\npublic:\n    // パスが実行されるときに呼び出されるメンバ関数\n    void run(wasm::PassRunner *pass_runner, wasm::Module *module) override {\n        // (省略)\n    }\n\n    // このパスが実行されたときにモジュールを改変するか\n    bool modifiesBinaryenIR() override {\n        // このカスタムパスはモジュールを改変しないのでfalseを返す\n        return false;\n    }\n};\n```\n\nこのパスを実行するには、`wasm::PassRunner`にこのクラスを登録します。\n\n#### main.cpp [(223行目-230行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L223-L230)\n\n```cpp\n// PassRunnerにカスタムパスを登録する\nwasm::PassRunner pass_runner{\u0026module};\npass_runner.add\u003cCountingPass\u003e();\n\n// カスタムパスを実行する\n// CountingPass::run()が呼び出される\npass_runner.run();\n```\n\n### 2.3. 式木訪問器(Visitor)を実装する\n\nモジュールに含まれる定数命令の数を数えるには式木訪問器(Visitor)を作成するのがもっとも簡単です。\n\n#### main.cpp [(6行目-191行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L6-L191)\n\n```cpp\nstruct CountingVisitor\n    : public wasm::OverriddenVisitor\u003cCountingVisitor, int\u003e {\n    // (省略)\n}\n```\n\n訪問器の基底クラスには`wasm::Visitor\u003c\u003e`、`wasm::OverriddenVisitor\u003c\u003e`などいくつかのクラスがあります。\nそれぞれに特徴があるのですが、基本的には`wasm::OverriddenVisitor\u003c\u003e`を継承するのがよいでしょう。\n\n`wasm::OverriddenVisitor\u003c\u003e`の第1テンプレート引数に自身のクラス型を、第2テンプレート引数には個々の`visit`関数の返り値の型を指定します。\n\n`visit`関数は式木の各ノードを順番に走査するためのメンバ関数です。\n\n今回のVisitorの`visit`関数はそのノードと子ノードに含まれる定数命令の数を返します。\n\n例として、定数命令(`i32.const`命令など)と条件分岐命令(`if`命令)の`visit`関数を挙げます。\n\n#### 定数命令の`visit`関数 - main.cpp [(129行目-131行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L129-L131)\n\n```cpp\n// 定数命令のvisit関数\nint visitConst(wasm::Const *curr) {\n    return 1;\n}\n```\n\n`wasm::Const`は定数命令に対応するノードクラスです。\n\nこのノードは定数命令なので常に`1`を返します。\n\n#### 条件分岐命令の`visit`関数 - main.cpp [(17行目-27行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L17-L27)\n\n```cpp\n// 条件分岐命令のvisit関数\nint visitIf(wasm::If *curr) {\n    int count = 0; // 子ノードに含まれる定数命令の数\n\n    // 条件式に含まれる定数命令を数える\n    count += visit(curr-\u003econdition);\n\n    // then節ブロックに含まれる定数命令を数える\n    count += visit(curr-\u003eifTrue);\n\n    // else節ブロックに含まれる定数命令を数える\n    if (curr-\u003eifFalse)\n        count += visit(curr-\u003eifFalse);\n\n    // 子ノードに含まれる定数命令の数を返す\n    return count;\n}\n```\n\n`wasm::If`は条件分岐命令(`if`命令)に対応するノードクラスです。\n\nこの命令は定数命令ではありませんが、3つのオペランドを持つためそれらのオペランド(子ノード)に含まれる定数命令を数える必要があります。\n\nただし、注意すべき点として一部の命令はそのオペランドの一部が**省略可能**であるため、子ノードを指すメンバ変数が`nullptr`になっていることがあります。\n\n`If`の`ifFalse`メンバも省略可能なオペランドを表す変数であるため、走査の前にそのオペランドが`nullptr`でないことを確認しなければなりません。\n\n### 2.4. 訪問器(Visitor)の呼び出し\n\n最後に作成したVisitorを呼び出す必要があります。\n\n#### main.cpp [(196行目-209行目)](https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L196-L209)\n\n```cpp\n// パスが実行されるときに呼び出されるメンバ関数\nvoid run(wasm::PassRunner *pass_runner, wasm::Module *module) override {\n    // Visitorオブジェクトを生成する\n    CountingVisitor visitor;\n\n    // モジュール内の関数に含まれる定数命令を数えていく\n    int count = 0;\n\n    for (const auto \u0026function : module-\u003efunctions) {\n        count += visitor.visitFunction(function.get());\n    }\n\n    // 出力する\n    std::cout \u003c\u003c count \u003c\u003c \" const instruction(s)\" \u003c\u003c std::endl;\n}\n```\n\n以上でWebAssemblyを走査できる簡単なパスを作成できました。","bodyHtml":"\u003cp\u003eLLVMはLLVM IRを操作・走査できるカスタムパスの作成をサポートしており、\u003ccode\u003eopt\u003c/code\u003eコマンドの\u003ccode\u003e-load\u003c/code\u003eオプションを利用することで作成したカスタムパスを簡単に適用できます。\u003c/p\u003e\n\u003cp\u003e参考： \u003ca href=\"http://llvm.org/docs/WritingAnLLVMPass.html\"\u003eLLVM documentation - Writing an LLVM Pass\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e同じく、\u003ca href=\"https://webassembly.org/\"\u003eWebAssembly\u003c/a\u003eのライブラリ・コンパイラ基盤である\u003ca href=\"https://github.com/WebAssembly/binaryen\"\u003eBinaryen\u003c/a\u003eでもカスタムパスの作成はサポートされています。\nしかし、LLVMにおける\u003ccode\u003eopt\u003c/code\u003eコマンドのような簡易的なドライバツールは付属されていないためドライバ部分もユーザが記述しなければなりません。\u003c/p\u003e\n\u003cp\u003e本稿ではWebAssembly中の定数命令の数を数える単純なコマンドラインツールの作成を通じて、以下の習得を目指します。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e任意のC/C++プロジェクトでBinaryenをライブラリとして利用する方法\u003c/li\u003e\n\u003cli\u003eWebAssemblyに対するカスタムパスの記述方法、および、その適用方法\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eBinaryenとは\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/WebAssembly/binaryen\"\u003eBinaryen\u003c/a\u003eはC++で記述された、WebAssembly操作するためのライブラリおよびツールチェインを提供するコンパイラ基盤です。\nBinaryenが提供するツールには例えば以下のようなものがあります。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ewasm-opt\u003c/code\u003e： WebAssemblyに、あらかじめ用意された最適化パスなどを適用するためのツール。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewasm-as\u003c/code\u003e： テキスト形式(\u003ccode\u003e.wast\u003c/code\u003eファイル)のWebAssemblyをバイナリ形式(\u003ccode\u003e.wasm\u003c/code\u003eファイル)へと変換するアセンブラ。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewasm-dis\u003c/code\u003e： バイナリ形式(\u003ccode\u003e.wasm\u003c/code\u003eファイル)のWebAssemblyをテキスト形式(\u003ccode\u003e.wast\u003c/code\u003eファイル)へと変換する逆アセンブラ。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eカスタムパスの作成\u003c/h2\u003e\n\u003cp\u003eテキスト形式(\u003ccode\u003e.wast\u003c/code\u003eファイル)あるいはバイナリ形式(\u003ccode\u003e.wasm\u003c/code\u003eファイル)のWebAssemblyを読み込み、その中に含まれる定数命令(\u003ccode\u003ei32.const\u003c/code\u003e, \u003ccode\u003ei64.const\u003c/code\u003e, \u003ccode\u003ef32.const\u003c/code\u003e, \u003ccode\u003ef64.const\u003c/code\u003e)を数える単純なツールを作成します。\u003c/p\u003e\n\u003cp\u003e以下のような単純なWebAssemblyモジュール\u003ccode\u003esimple.wast\u003c/code\u003eについて、含まれる定数命令の数は1つのみなので次のような出力が得られれば成功です。\u003c/p\u003e\n\u003ch4\u003esimple.wast\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e(\u003cspan class=\"hljs-name\"\u003emodule\u003c/span\u003e\n    (\u003cspan class=\"hljs-name\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;add3\u0026quot;\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003efunc\u003c/span\u003e $add3))\n    (\u003cspan class=\"hljs-name\"\u003efunc\u003c/span\u003e $add3 (\u003cspan class=\"hljs-name\"\u003eparam\u003c/span\u003e i32) (\u003cspan class=\"hljs-name\"\u003eresult\u003c/span\u003e i32)\n        (\u003cspan class=\"hljs-name\"\u003ei32\u003c/span\u003e.add\n            (\u003cspan class=\"hljs-name\"\u003elocal\u003c/span\u003e.get \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n            (\u003cspan class=\"hljs-name\"\u003ei32\u003c/span\u003e.const \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)))\n)\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e実行例\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-meta\"\u003e$\u003c/span\u003e\u003cspan class=\"bash\"\u003e count-const simple.wast\u003c/span\u003e\n1 const instruction(s)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e作成したプロジェクトの一式はGitHubで公開しています。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter\"\u003ebinaryen-const-counter\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e1. ビルドルールを記述する\u003c/h2\u003e\n\u003ch3\u003e1.1. CMakeLists.txtを記述する\u003c/h3\u003e\n\u003cp\u003eプロジェクトはCMakeを用いてビルドするため、\u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/master/CMakeLists.txt\"\u003eCMakeLists.txt\u003c/a\u003eを記述する必要があります。\u003c/p\u003e\n\u003ch4\u003eCMakeLists.txt \u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L1-L13\"\u003e(1行目-13行目)\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003ecmake_minimum_required\u003c/span\u003e(VERSION \u003cspan class=\"hljs-number\"\u003e3.0\u003c/span\u003e.\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003eproject\u003c/span\u003e(binaryen-const-counter VERSION \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e.\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e LANGUAGES CXX)\n\n\u003cspan class=\"hljs-comment\"\u003e# ビルドオプションの指定\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e(CMAKE_CXX_FLAGS \u003cspan class=\"hljs-string\"\u003e\u0026quot;-std=c++17 -Wall -Wextra -Werror -pedantic\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e(CMAKE_CXX_FLAGS_DEBUG \u003cspan class=\"hljs-string\"\u003e\u0026quot;-g3 -O0 -pg\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e(CMAKE_CXX_FLAGS_RELEASE \u003cspan class=\"hljs-string\"\u003e\u0026quot;-O2 -DNDEBUG -march=native\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e(CMAKE_CXX_FLAGS_RELWITHDEBINFO \u003cspan class=\"hljs-string\"\u003e\u0026quot;-g3 -Og -pg\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e(CMAKE_CXX_FLAGS_MINSIZEREL \u003cspan class=\"hljs-string\"\u003e\u0026quot;-Os -DNDEBUG -march=native\u0026quot;\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eNOT\u003c/span\u003e CMAKE_BUILD_TYPE)\n    \u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e(CMAKE_BUILD_TYPE Release)\n\u003cspan class=\"hljs-keyword\"\u003eendif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eNOT\u003c/span\u003e CMAKE_BUILD_TYPE)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eビルドオプションなどは好みに応じて指定してください。\u003c/p\u003e\n\u003ch3\u003e1.2. Binaryenをライブラリとしてインポートする\u003c/h3\u003e\n\u003cp\u003eCMakeのプラグインであるExternalProjectを用いてBinaryenをインポートします。また、\u003ccode\u003epthread\u003c/code\u003eをリンクする必要があるのでそのための準備も行います。\u003c/p\u003e\n\u003ch4\u003eCMakeLists.txt \u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L15-L28\"\u003e(15行目-28行目)\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 環境ごとのThreadライブラリを見つける\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efind_package\u003c/span\u003e(Threads REQUIRED)\n\n\u003cspan class=\"hljs-comment\"\u003e# ExternalProjectを使用する\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e(ExternalProject)\n\n\u003cspan class=\"hljs-comment\"\u003e# Binaryenをビルド、インポートする\u003c/span\u003e\nExternalProject_Add(\n    binaryen\n    URL \u003cspan class=\"hljs-string\"\u003e\u0026quot;https://github.com/WebAssembly/binaryen/archive/version_83.tar.gz\u0026quot;\u003c/span\u003e\n    PREFIX binaryen\n    INSTALL_COMMAND \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e\n    TEST_COMMAND \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e\n    CMAKE_ARGS\n        -DBUILD_STATIC_LIB=\u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n        -DCMAKE_BUILD_TYPE=Release\n)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eCMAKE_ARGS -DBUILD_STATIC_LIB=ON\u003c/code\u003eを指定することで静的ライブラリファイルが生成されるようにしています。\u003c/p\u003e\n\u003cp\u003eBinaryenは本稿執筆時点の最新バージョンである\u003ccode\u003eversion_83\u003c/code\u003eをインポートしています。\nBinaryenは2019年5月現在も盛んに更新がなされているので使用する時点の最新バージョンを使用することをおすすめします。\u003c/p\u003e\n\u003ch3\u003e1.3. 生成されたBinaryenのライブラリファイルをCMakeプロジェクトとしてインポートする\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eExternalProject_Add\u003c/code\u003eでインポートしたプロジェクトはそのままでは他のターゲットにリンクできません。\u003c/p\u003e\n\u003cp\u003eそのため、\u003ccode\u003eIMPORTED\u003c/code\u003eターゲットを作成する作成する必要があります。\u003c/p\u003e\n\u003ch4\u003eCMakeLists.txt \u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L30-L55\"\u003e(30行目-55行目)\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 展開されたBinaryenのソースパス、バイナリパスを取得する\u003c/span\u003e\nExternalProject_Get_Property(binaryen source_dir)\nExternalProject_Get_Property(binaryen binary_dir)\n\n\u003cspan class=\"hljs-comment\"\u003e# IMPORTEDライブラリターゲットを追加する\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eadd_library\u003c/span\u003e(binaryen::binaryen STATIC IMPORTED)\n\u003cspan class=\"hljs-comment\"\u003e# ターゲットの依存関係を定義する\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eadd_dependencies\u003c/span\u003e(binaryen::binaryen binaryen)\n\n\u003cspan class=\"hljs-comment\"\u003e# インポートする静的ライブラリのパス\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e(binaryen_LIBS\n    \u003cspan class=\"hljs-variable\"\u003e${binary_dir}\u003c/span\u003e/lib/libwasm.a\n    \u003cspan class=\"hljs-variable\"\u003e${binary_dir}\u003c/span\u003e/lib/libasmjs.a\n    \u003cspan class=\"hljs-variable\"\u003e${binary_dir}\u003c/span\u003e/lib/libpasses.a\n    \u003cspan class=\"hljs-variable\"\u003e${binary_dir}\u003c/span\u003e/lib/libcfg.a\n    \u003cspan class=\"hljs-variable\"\u003e${binary_dir}\u003c/span\u003e/lib/libir.a\n    \u003cspan class=\"hljs-variable\"\u003e${binary_dir}\u003c/span\u003e/lib/libemscripten-optimizer.a\n    \u003cspan class=\"hljs-variable\"\u003e${binary_dir}\u003c/span\u003e/lib/libsupport.a\n    \u003cspan class=\"hljs-variable\"\u003e${binary_dir}\u003c/span\u003e/lib/libwasm.a \u003cspan class=\"hljs-comment\"\u003e# 2度指定する(重要)\u003c/span\u003e\n    Threads::Threads\n)\n\n\u003cspan class=\"hljs-comment\"\u003e# 存在しないディレクトリをINTERFACE_INCLUDE_DIRECTORIESに指定すると\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e# 警告が出るのでそれを回避するためにディレクトリを作成する\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efile\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eMAKE_DIRECTORY\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003e${source_dir}\u003c/span\u003e/src)\n\n\u003cspan class=\"hljs-comment\"\u003e# IMPORTEDターゲットのincludeディレクトリと静的ライブラリファイルを指定する\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eset_target_properties\u003c/span\u003e(binaryen::binaryen\n    PROPERTIES\n    IMPORTED_LOCATION \u003cspan class=\"hljs-variable\"\u003e${binary_dir}\u003c/span\u003e/lib/libbinaryen.a\n    INTERFACE_INCLUDE_DIRECTORIES \u003cspan class=\"hljs-variable\"\u003e${source_dir}\u003c/span\u003e/src\n    INTERFACE_LINK_LIBRARIES \u003cspan class=\"hljs-string\"\u003e\u0026quot;${binaryen_LIBS}\u0026quot;\u003c/span\u003e\n)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e重要なのは\u003ccode\u003elibwasm.a\u003c/code\u003eを2回指定していることです。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003elibwasm.a\u003c/code\u003eと\u003ccode\u003elibpasses.a\u003c/code\u003eなどは相互に参照しあっているため、最初と最後の両方に\u003ccode\u003elibwasm.a\u003c/code\u003eを指定しないとリンカエラーが発生してしまいます。\u003c/p\u003e\n\u003ch3\u003e1.4. カスタムパスのターゲットを追加する\u003c/h3\u003e\n\u003cp\u003e最後にカスタムパスをビルドするためにターゲットを追加します。\u003c/p\u003e\n\u003ch4\u003eCMakeLists.txt \u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/CMakeLists.txt#L57-L63\"\u003e(57行目-63行目)\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e# ターゲットを追加する\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eadd_executable\u003c/span\u003e(count-const\n    main.cpp\n)\n\n\u003cspan class=\"hljs-comment\"\u003e# Binaryenをリンクする\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etarget_link_libraries\u003c/span\u003e(count-const\n    binaryen::binaryen\n)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e以上でCMakeを使ったビルドルールの記述が完了しました。\u003c/p\u003e\n\u003ch2\u003e2. カスタムパスを作成する\u003c/h2\u003e\n\u003cp\u003e続いてBinaryenを利用してカスタムパスを作成していきます。\u003c/p\u003e\n\u003ch3\u003e2.1. WebAssemblyモジュールを読み込む\u003c/h3\u003e\n\u003cp\u003eコマンドライン引数で指定されたWebAssemblyファイルを読み込みます。\u003c/p\u003e\n\u003ch4\u003emain.cpp \u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L223-L225\"\u003e(223行目-225行目)\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// WebAssemblyモジュールを読み込む\u003c/span\u003e\nwasm::Module \u003cspan class=\"hljs-keyword\"\u003emodule\u003c/span\u003e;\nwasm::ModuleReader{}.\u003cspan class=\"hljs-built_in\"\u003eread\u003c/span\u003e(argv[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], \u003cspan class=\"hljs-keyword\"\u003emodule\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWebAssemblyモジュールファイルを読み込むには、以下の関数のうちのいずれかを使用します。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ewasm::ModuleReader::readText()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWebAssemblyテキストファイル(\u003ccode\u003e.wast\u003c/code\u003e形式)を読み込む。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ewasm::ModuleReader::readBinary()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWebAssemblyバイナリファイル(\u003ccode\u003e.wasm\u003c/code\u003e形式)を読み込む。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ewasm::ModuleReader::read()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eテキストファイルかバイナリファイル化を自動で判断して読み込む。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eテキストファイル(\u003ccode\u003e.wast\u003c/code\u003e)とバイナリファイル(\u003ccode\u003e.wasm\u003c/code\u003e)の両方に対応したければ\u003ccode\u003eread()\u003c/code\u003eを使用すればよいです。\u003c/p\u003e\n\u003cp\u003e読み込むときに注意すべき点は2つです。\u003c/p\u003e\n\u003ch4\u003e1. 読み込むファイルが開けなければ\u003ccode\u003eexit(1)\u003c/code\u003eを呼び出す\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ereadText()\u003c/code\u003e、\u003ccode\u003ereadBinary()\u003c/code\u003e、\u003ccode\u003eread()\u003c/code\u003e関数はファイルが開けない場合(存在しない場合など)には即座に\u003ccode\u003eexit(EXIT_FAILURE)\u003c/code\u003eを呼び出し終了します。\u003c/p\u003e\n\u003cp\u003eよりよいエラーのハンドリングを行う場合には実装を参考に自ら読み込み処理を必要があります。\u003c/p\u003e\n\u003ch4\u003e2. ファイル形式が間違っている場合に\u003ccode\u003ewasm::ParseException\u003c/code\u003e例外を投げる\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ereadText()\u003c/code\u003e、\u003ccode\u003ereadBinary()\u003c/code\u003e、\u003ccode\u003eread()\u003c/code\u003e関数はファイルの形式が間違っている場合に\u003ccode\u003ewasm::ParseException\u003c/code\u003e例外を投げます。\u003c/p\u003e\n\u003cp\u003eしかし、この\u003ccode\u003ewasm::ParseException\u003c/code\u003eは\u003ccode\u003estd::exception\u003c/code\u003eを\u003cstrong\u003e継承していない\u003c/strong\u003eため注意が必要です。\u003c/p\u003e\n\u003ch3\u003e2.2. パスを実装する\u003c/h3\u003e\n\u003cp\u003eカスタムパスを実装するためには\u003ccode\u003ewasm::Pass\u003c/code\u003e抽象クラスを継承します。\u003c/p\u003e\n\u003ch4\u003emain.cpp \u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L193-L214\"\u003e(193行目-214行目)\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// カスタムパスクラス\u003c/span\u003e\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCountingPass\u003c/span\u003e :\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e wasm::Pass {\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// パスが実行されるときに呼び出されるメンバ関数\u003c/span\u003e\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erun\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(wasm::PassRunner *pass_runner, wasm::Module *\u003cspan class=\"hljs-keyword\"\u003emodule\u003c/span\u003e)\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003c/span\u003e{\n        \u003cspan class=\"hljs-comment\"\u003e// (省略)\u003c/span\u003e\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// このパスが実行されたときにモジュールを改変するか\u003c/span\u003e\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003ebool\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emodifiesBinaryenIR\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003c/span\u003e{\n        \u003cspan class=\"hljs-comment\"\u003e// このカスタムパスはモジュールを改変しないのでfalseを返す\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    }\n};\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eこのパスを実行するには、\u003ccode\u003ewasm::PassRunner\u003c/code\u003eにこのクラスを登録します。\u003c/p\u003e\n\u003ch4\u003emain.cpp \u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L223-L230\"\u003e(223行目-230行目)\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// PassRunnerにカスタムパスを登録する\u003c/span\u003e\nwasm::PassRunner pass_runner{\u0026amp;\u003cspan class=\"hljs-keyword\"\u003emodule\u003c/span\u003e};\npass_runner.add\u0026lt;CountingPass\u0026gt;();\n\n\u003cspan class=\"hljs-comment\"\u003e// カスタムパスを実行する\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// CountingPass::run()が呼び出される\u003c/span\u003e\npass_runner.\u003cspan class=\"hljs-built_in\"\u003erun\u003c/span\u003e();\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e2.3. 式木訪問器(Visitor)を実装する\u003c/h3\u003e\n\u003cp\u003eモジュールに含まれる定数命令の数を数えるには式木訪問器(Visitor)を作成するのがもっとも簡単です。\u003c/p\u003e\n\u003ch4\u003emain.cpp \u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L6-L191\"\u003e(6行目-191行目)\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCountingVisitor\u003c/span\u003e\n    :\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e wasm::OverriddenVisitor\u0026lt;CountingVisitor, \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e\u0026gt; {\n    \u003cspan class=\"hljs-comment\"\u003e// (省略)\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e訪問器の基底クラスには\u003ccode\u003ewasm::Visitor\u0026lt;\u0026gt;\u003c/code\u003e、\u003ccode\u003ewasm::OverriddenVisitor\u0026lt;\u0026gt;\u003c/code\u003eなどいくつかのクラスがあります。\nそれぞれに特徴があるのですが、基本的には\u003ccode\u003ewasm::OverriddenVisitor\u0026lt;\u0026gt;\u003c/code\u003eを継承するのがよいでしょう。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewasm::OverriddenVisitor\u0026lt;\u0026gt;\u003c/code\u003eの第1テンプレート引数に自身のクラス型を、第2テンプレート引数には個々の\u003ccode\u003evisit\u003c/code\u003e関数の返り値の型を指定します。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003evisit\u003c/code\u003e関数は式木の各ノードを順番に走査するためのメンバ関数です。\u003c/p\u003e\n\u003cp\u003e今回のVisitorの\u003ccode\u003evisit\u003c/code\u003e関数はそのノードと子ノードに含まれる定数命令の数を返します。\u003c/p\u003e\n\u003cp\u003e例として、定数命令(\u003ccode\u003ei32.const\u003c/code\u003e命令など)と条件分岐命令(\u003ccode\u003eif\u003c/code\u003e命令)の\u003ccode\u003evisit\u003c/code\u003e関数を挙げます。\u003c/p\u003e\n\u003ch4\u003e定数命令の\u003ccode\u003evisit\u003c/code\u003e関数 - main.cpp \u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L129-L131\"\u003e(129行目-131行目)\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 定数命令のvisit関数\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003evisitConst\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(wasm::Const *curr)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003ewasm::Const\u003c/code\u003eは定数命令に対応するノードクラスです。\u003c/p\u003e\n\u003cp\u003eこのノードは定数命令なので常に\u003ccode\u003e1\u003c/code\u003eを返します。\u003c/p\u003e\n\u003ch4\u003e条件分岐命令の\u003ccode\u003evisit\u003c/code\u003e関数 - main.cpp \u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L17-L27\"\u003e(17行目-27行目)\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 条件分岐命令のvisit関数\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003evisitIf\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(wasm::If *curr)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e count = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 子ノードに含まれる定数命令の数\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e// 条件式に含まれる定数命令を数える\u003c/span\u003e\n    count += \u003cspan class=\"hljs-built_in\"\u003evisit\u003c/span\u003e(curr-\u0026gt;condition);\n\n    \u003cspan class=\"hljs-comment\"\u003e// then節ブロックに含まれる定数命令を数える\u003c/span\u003e\n    count += \u003cspan class=\"hljs-built_in\"\u003evisit\u003c/span\u003e(curr-\u0026gt;ifTrue);\n\n    \u003cspan class=\"hljs-comment\"\u003e// else節ブロックに含まれる定数命令を数える\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (curr-\u0026gt;ifFalse)\n        count += \u003cspan class=\"hljs-built_in\"\u003evisit\u003c/span\u003e(curr-\u0026gt;ifFalse);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 子ノードに含まれる定数命令の数を返す\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e count;\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003ewasm::If\u003c/code\u003eは条件分岐命令(\u003ccode\u003eif\u003c/code\u003e命令)に対応するノードクラスです。\u003c/p\u003e\n\u003cp\u003eこの命令は定数命令ではありませんが、3つのオペランドを持つためそれらのオペランド(子ノード)に含まれる定数命令を数える必要があります。\u003c/p\u003e\n\u003cp\u003eただし、注意すべき点として一部の命令はそのオペランドの一部が\u003cstrong\u003e省略可能\u003c/strong\u003eであるため、子ノードを指すメンバ変数が\u003ccode\u003enullptr\u003c/code\u003eになっていることがあります。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eIf\u003c/code\u003eの\u003ccode\u003eifFalse\u003c/code\u003eメンバも省略可能なオペランドを表す変数であるため、走査の前にそのオペランドが\u003ccode\u003enullptr\u003c/code\u003eでないことを確認しなければなりません。\u003c/p\u003e\n\u003ch3\u003e2.4. 訪問器(Visitor)の呼び出し\u003c/h3\u003e\n\u003cp\u003e最後に作成したVisitorを呼び出す必要があります。\u003c/p\u003e\n\u003ch4\u003emain.cpp \u003ca href=\"https://github.com/NagayamaRyoga/binaryen-const-counter/blob/87c23aacf472c5711377a84ea88dc78addf0ffbc/main.cpp#L196-L209\"\u003e(196行目-209行目)\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// パスが実行されるときに呼び出されるメンバ関数\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erun\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(wasm::PassRunner *pass_runner, wasm::Module *\u003cspan class=\"hljs-keyword\"\u003emodule\u003c/span\u003e)\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// Visitorオブジェクトを生成する\u003c/span\u003e\n    CountingVisitor visitor;\n\n    \u003cspan class=\"hljs-comment\"\u003e// モジュール内の関数に含まれる定数命令を数えていく\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e count = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e \u0026amp;function : \u003cspan class=\"hljs-keyword\"\u003emodule\u003c/span\u003e-\u0026gt;functions) {\n        count += visitor.\u003cspan class=\"hljs-built_in\"\u003evisitFunction\u003c/span\u003e(function.\u003cspan class=\"hljs-built_in\"\u003eget\u003c/span\u003e());\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 出力する\u003c/span\u003e\n    std::cout \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\u0026quot; const instruction(s)\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e以上でWebAssemblyを走査できる簡単なパスを作成できました。\u003c/p\u003e\n","preview":"LLVMはLLVM IRを操作・走査できるカスタムパスの作成をサポートしており、optコマンドの-loadオプションを利用することで作成したカスタムパスを簡単に適用できます。\n\n参考： LLVM documentation - Writing an LLVM Pass","sourceBase":"2019-05-08-writing-wasm-passes.md"}},"__N_SSG":true},"page":"/[article]","query":{"article":"2019-05-08-writing-wasm-passes"},"buildId":"l5V8wPf0_DsbrjWIZ630X","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>